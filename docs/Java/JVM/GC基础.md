## 判断一个对象是否可被回收
### 1. 引用计数算法
给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。
两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。
正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。、
```java
public class ReferenceCountingGC {

    public Object instance = null;

    public static void main(String[] args) {
        ReferenceCountingGC objectA = new ReferenceCountingGC();
        ReferenceCountingGC objectB = new ReferenceCountingGC();
        objectA.instance = objectB;
        objectB.instance = objectA;
    }
}
```
### 2. 可达性分析算法
通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。
![](https://raw.githubusercontent.com/danmuking/image/main/997334e8215ac38b84aa802d3b239e44.png)
Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象
### 3. 方法区的回收
因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。
主要是对常量池的回收和对类的卸载。
在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。
类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:

- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。
- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。
### 4. finalize()
finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。
当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。
## 三色标记算法
### 三色标记算法
**既然叫三色标记算法，首先我们要搞明白是哪三色，三色是：黑色，白色，灰色。**
把可达性分析遍历对象图过程中遇到的对象，按照「**是否访问过**」这个条件标记成以下三种颜色：

- **白色**：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- **黑色**：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。
- **灰色**：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

《深入理解Java虚拟机》书中关于这块图画的很好，一目了然，直接上原图：
![](https://raw.githubusercontent.com/danmuking/image/main/52676c77fec3a2e374329c5131fffc9e.png)
从上面这段话中，我们提炼一下关键要点：

- 初始阶段，GC Root是黑色的，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- 如果有其他对象引用指向了黑色对象，无须重新扫描一遍。
- 黑色对象不可能直接指向某个白色对象。

让我来给大伙稍微解释一下第二点和第三点。
![](https://raw.githubusercontent.com/danmuking/image/main/84e83722b6bfdb4da7d1ec11a9ac22da.png)
我上面画了一个示意图，第一幅和第二幅画的是对的，第三幅画的是错的。
先分析第二点，**如果有其他对象引用指向了黑色对象，那么这个对象只能为灰色或者黑色**，自然无须再重新扫描一遍。
然后再说第三点，黑色对象不可能直接指向某个白色对象。
我们从上面可知黑色对象的定义是：「**对象的所有引用都已经扫描过**」，而白色对象是：「**对象尚未被垃圾收集器访问过**」。
那么问题来了，**如果黑色对象直接指向某个白色对象，那么他就跟黑色对象的定义矛盾了。**
因为白色对象还没被访问过，怎么能算所有引用都扫描过了呢，所以他就不可能是黑色。
![](https://raw.githubusercontent.com/danmuking/image/main/98a411269f4e6c32425d330555fffd5f.jpeg)
上面这个很重要，把这个理解透彻之后，我们看看三色标记算法存在的一些问题：
**由于一些垃圾回收器存在垃圾回收线程和用户线程并发的情况（例如CMS的并发阶段），那么三色标记会有两个问题：**
![](https://raw.githubusercontent.com/danmuking/image/main/3ce44fefece471a3fdde3fcc4617707a.png)

- 一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好，问题不大。
- 另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。

第一点无伤大雅，所以我们解决问题的重心放到第二点上。
1994年理论上被证明了，「**当且仅当以下两个条件同时满足时**」，会产生「**对象消失**」的问题，即原本应该是黑色的对象被误标为白色：

- 赋值器插入了一条或多条从黑色对象到白色对象的新引用。
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

其实一句话说白了就是：「**跟灰色对象断开连接，跟黑色对象建立连接**」。
因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件中的任意一个即可。
由此分别产生了两种解决方案：「**增量更新（Incremental Update）**」和「**原始快照（Snapshot At The Beginning，SATB）**」。
这两个解决方案各破坏一个条件。
### 增量更新（CMS）
增量更新要破坏的是第一个条件。
**当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。**
这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
这其实有点像之前讲过类似OopMap的思想，本质也是维护了个映射关系，扫描结束的时候把这个映射关系再重新扫描一遍，不用全局扫描。
![](https://raw.githubusercontent.com/danmuking/image/main/68cd589912d11b4435dff0596ad046d8.png)
如图，将这个新插入的引用关系记录下来，扫描结束之后，将记录过的引用关系中的黑色对象1为根，重新扫描一次，就OK了。
### 原始快照（G1）
原始快照要破坏的是第二个条件。
**当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。**
这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的「**对象图快照**」来进行搜索，故名「**原始快照**」。
![](https://raw.githubusercontent.com/danmuking/image/main/ea5a939ec30bf43255217dce44883dd5.png)
如图，将这个删除的引用关系记录下来，扫描结束之后，将记录过的引用关系中的灰色对象2为根，重新扫描一次，就OK了。
那么有个问题，增量更新和原始快照都需要记录引用关系，那这个记录的时间点发生在什么时刻呢？
不知道大家还是否记得之前说过的「**写屏障**」，是的没错。
![](https://raw.githubusercontent.com/danmuking/image/main/130bfbc1c45e89fccc63e33a494d9d43.jpeg)
**无论是增量更新还是原始快照，虚拟机的记录操作都是通过写屏障实现的。**
写屏障，我们之前讲记忆集与卡表的时候介绍过的，可以理解为Spring中的AOP，目前为止卡表状态的维护，增量更新，原始快照都是基于写屏障。
## GC如何快速枚举根节点
### 什么是根节点枚举
顾名思义，根节点枚举就是找出所有的GC Roots。
当然要成为GC Roots是有条件的，固定可作为GC Roots的对象包括以下几种（摘抄自《深入理解虚拟机 第3版》）：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
- 所有被同步锁（synchronized关键字）持有的对象。
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

![](https://raw.githubusercontent.com/danmuking/image/main/f489daa02032f4d7503b3c41b2101a4b.png)
上面说的这些，大伙肯定记不住，反正总结就一句话：**固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中。**
### 根节点枚举存在的问题
迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的「**Stop The World**」的困扰。
根节点枚举必须在一个能保障一致性的快照中才得以进行——这里「一致性」的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上。
![](https://raw.githubusercontent.com/danmuking/image/main/013171f0a2c1efea8e4ff29065063447.jpeg)
**为什么要这么做？**
试想一下，你妈给你打扫房间，你妈一边打扫，你一边丢垃圾，房间永远也打扫不干净。
**所以本质上来说，根节点枚举遇到的问题，就是并发问题。**
如果不「冻结」的话，根节点集合的对象引用关系在不断变化，那么分析结果准确性也就无法保证。
所以即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，在枚举根节点这一步也是必须要停顿的。
### 如何解决根节点枚举的问题
目前主流Java虚拟机使用的都是「**准确式垃圾收集**」。
所谓准确式垃圾收集是指垃圾收集器能够精确地确定内存中哪些区域被对象引用，哪些区域已经不再使用，并且可以立即回收不再使用的内存。
在准确式垃圾收集中，垃圾收集器需要知道每一个引用类型变量（包括实例字段、静态字段、本地变量和输入参数等）在内存中的确切位置，以及这个位置是否正在被引用。
这样，当垃圾收集器需要进行回收时，它就可以精确地找到并回收那些不再有任何引用的对象所占用的内存。
相对应的，还有一种叫做「**保守式垃圾收集**」，它不能精确地识别所有的引用，只能保守地认为所有看起来像对象引用的值都可能是引用。这种方式可能会导致某些实际上可以被回收的内存得不到回收。
**HotSpot采用的是准确式垃圾收集**。
所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。
**在HotSpot的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。OopMap可以理解为就是映射表，存储栈上的对象引用的信息，这是一种空间换时间的做法。**
在 GC Roots 枚举时，只需要遍历每个栈桢的 OopMap，通过 OopMap 存储的信息，快捷地找到 GC Roots，这样就不需要进行全局扫描。
**用大白话说，其实就是用类似映射表这种手段记录下来引用关系，时不时去更新下映射表，然后根节点枚举只需要扫描映射表就知道哪些地方存放引用了，而不用去进行全局扫描。**
OK，弄明白之后，问题又来了，既然OopMap是一个映射表，这个表什么时候被更新？
你可能会觉得这有啥难的，引用更新的时候同步去更新映射表不就完事了吗，然而事情并没有想的那么简单。
要知道引用关系变化是十分频繁的，如果引用每变化一次就更新对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。
### 安全点
解决这个问题的办法就是「**安全点**」，事实上，只是在「特定的位置」记录了这些信息，这些位置被称为安全点（Safepoint）。
**因此GC不是随时随地来的，得到达安全点时才可以开始GC。**
**所以流程我们就清楚了：先是到达安全点，然后更新OopMp，然后进行根节点枚举，找到GC Roots，开始GC。**
![](https://raw.githubusercontent.com/danmuking/image/main/d172bbc5050e16c4a7e89c0cf6d3f772.png)
安全点的选举，一般会在如下几个位置出现：

- 循环的末尾
- 方法临返回前
- 调用方法之后
- 抛异常的位置

到这里为止，貌似问题我们都解决了，but，还有一个问题我们需要考虑，我们前面说了系统要在某个时间点处于「冻结」状态，**那么如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来？**
![](https://raw.githubusercontent.com/danmuking/image/main/1f851240898940cc436e3c704ef6b5b3.jpeg)
有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

- 「抢先式中断」：不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，**如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。**现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。

![](https://raw.githubusercontent.com/danmuking/image/main/7f8ea426d235edf3112cfaf02420624c.png)

- 「主动式中断」：当垃圾收集需要中断线程的时候，**不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。**

安全点的设计似乎已经完美解决如何停顿用户线程，但是仍然有问题，安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序「**不执行**」的时候呢？
所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己。
对于这种情况，JVM引入安全区域（Safe Region）来解决。
### 安全区域
**安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化。**因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。
![](https://raw.githubusercontent.com/danmuking/image/main/1f1c86ec6d2da61e6812f9a2e705ebe7.png)
当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域。
那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。
**当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段）。**
如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。
## 引用类型
无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。
Java 具有四种强度不同的引用类型。
### 强引用
被强引用关联的对象不会被回收。
使用 new 一个新对象的方式来创建强引用。
```java
Object obj = new Object();
```
### 软引用
被软引用关联的对象只有在内存不够的情况下才会被回收。
使用 SoftReference 类来创建软引用。
```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```
### 弱引用
被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
使用 WeakReference 类来实现弱引用。
```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```
### 虚引用
又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。
为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。
使用 PhantomReference 来实现虚引用。
```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```
## JVM如何解决跨代引用
### 跨代引用问题
**跨代引用是指新生代中存在对老年代对象的引用，或者老年代中存在对新生代的引用。**
为什么说这是一个问题呢？请看下图。
![](https://raw.githubusercontent.com/danmuking/image/main/6b21ef9a4477168371511bd0c7161f5b.png)
假如现在要进行一次只局限于新生代区域的YGC，但新生代中的对象是完全有可能被老年代所引用的，为了找到新生代中的存活对象，不得不遍历整个老年代来确保可达性分析结果的正确性。
**首先，我们得明确一点，跨代引用是极少的，这很重要。**
举个例子说明：如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。
JVM的设计者已经考虑到了这个场景，并想到了解决办法，那就是使用一种叫做：「**记忆集（Remembered Set）**」的数据结构。
### 记忆集
**记忆集位于新生代中，是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。用以避免把整个老年代加进GC Roots扫描范围。**
![](https://raw.githubusercontent.com/danmuking/image/main/74cac23c778d54a3f4738ee47ef8c823.png)
**记忆集的作用和我们之前讲的OopMap很相似，维护了类似一种映射表的关系，避免了全局扫描，本质是用空间换时间。**
此后当发生YGC时，只要把记忆集加进来一起扫描，就能知道新生代对象被老年代引用的情况，而不必扫描整个老年代！
虽然说增加了维护记忆集的成本，但比起收集时扫描整个老年代来说这波还是血赚！
上面不知道大家有没有留意我的说辞：「**抽象数据结构**」。意思就是说记忆集是一种逻辑上的概念，并没有规定具体的实现，类似方法区。
**在HotSpot中，采用卡表去实现记忆集。可以把记忆集和卡表的关系理解为Map跟HashMap。**
### 卡表
**卡表可以理解为是记忆集的具体实现，英文叫：Card Table。**
垃圾收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。
那设计者在实现记忆集的时候，便可以选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范围以外的）的记录精度：
![](https://raw.githubusercontent.com/danmuking/image/main/003849e24d27be50dcf50d4e85ec4f24.png)
**其中，第三种「卡精度」所指的就是「卡表」的方式去实现记忆集 ，这也是目前最常用的一种记忆集实现形式，HotSpot采用的就是卡表。**
在HotSpot虚拟机里面，卡表采用的是字节数组的形式。以下这行代码是HotSpot默认的卡表标记逻辑 ：
```kotlin
CARD_TABLE [this address >> 9] = 0;
```
**字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作「卡页（Card Page）」。**
一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可以看出HotSpot中使用的卡页是2的9次幂，即512字节。
意味着如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块 ，如图所示：
![](https://raw.githubusercontent.com/danmuking/image/main/682bef105d448f79f6816abc9d5209ae.png)
一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。
**简单来说，就是卡页的字节数组只有0和1两种状态，1表示哪些内存区域存在跨代指针，那么只要把1的加入GC Roots中一并扫描，就能知道哪些进行跨代引用了，这样就不用挨个去扫描了。**
OK，到了这步我们的思路就清晰了。
**可以把老年代划分为一个个内存区域，每块内存区域分别对应卡表的元素，然后把卡表中变脏的元素，直接加入GC Roots中一并扫描，跨代引用问题就迎刃而解了。**
![](https://raw.githubusercontent.com/danmuking/image/main/ce5e520b3e98dd40261ede74a5635c28.png)
如图，对象A在老年代 0x0000～0x01FF 内存区域被引用，那只要把对应的卡表标记为1，YGC的时候扫描卡表，就能知道对象A被老年代哪块内存区域引用了。
**but，我们还剩下一个问题，卡表元素如何维护？类似问题OopMap也遇到过。**
**卡表元素如何维护？何时变脏？谁来把它们变脏？**
![](https://raw.githubusercontent.com/danmuking/image/main/2e7eb345dbe9006631c8f940b906dcc2.png)
**HotSpot解决的办法是使用写屏障。**
### 写屏障
先来解决何时变脏的问题，这个问题很简单，即**其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻**。
但问题是如何变脏，即如何在对象赋值的那一刻去更新维护卡表。
在HotSpot虚拟机里是通过「**写屏障（Write Barrier）**」解决的。
注意：这里提到的 写屏障 和 volatile 的写屏障不是一回事。
**写屏障可以看作在虚拟机层面对「引用类型字段赋值」这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知。用过Spring的弟兄们对AOP肯定不陌生。**
![](https://raw.githubusercontent.com/danmuking/image/main/85ab92c766634e111794b9c0559baf7f.jpeg)
在赋值前的部分的写屏障叫作「**写前屏障（Pre-Write Barrier）**」，在赋值后的则叫作「**写后屏障（Post-Write Barrier）**」。
HotSpot虚拟机的许多收集器中都有使用到写屏障，**但直至G1收集器出现之前，其他收集器都只用到了写后屏障。**
应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与YGC时扫描整个老年代的代价相比还是低得多的。
当引入一个解决方案的时候，随之而来的可能还有其他问题。卡表在高并发场景下还面临着「**伪共享（False Sharing）**」问题。
### 写屏障的伪共享问题
伪共享是处理并发底层细节时一种经常需要考虑的问题，号称并发的「**隐形杀手**」。
现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低。
![](https://raw.githubusercontent.com/danmuking/image/main/7f7831fc3938ed501f6616d442b85a65.png)
core1 更新 A，同时 core2 更新 B，由于数据的读取和更新是以「**缓存行**」为单位的，这就意味着当这两件事同时发生时，就产生了竞争，导致 core1 和 core2 有可能需要重新刷新自己的数据（缓存行被对方更新了），最终导致系统的性能大打折扣，这就是伪共享问题。
**为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。**
即将卡表更新的逻辑变为以下代码所示：
```
if (CARD_TABLE [this address >> 9] != 0)
CARD_TABLE [this address >> 9] = 0;
```
相当于说其实就是多了一个「**if 判断条件**」。
在JDK 7之后，HotSpot虚拟机增加了一个新的参数「**-XX：+UseCondCardMark**」，此参数默认是关闭的，用来决定是否开启卡表更新的条件判断。
开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。
## 垃圾回收算法
### 1. 标记 - 清除
![](https://raw.githubusercontent.com/danmuking/image/main/8bff61d9bb23a3931981f2d917179588.jpeg)
将存活的对象进行标记，然后清理掉未被标记的对象。
不足:

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。
### 2. 标记 - 整理
![](https://raw.githubusercontent.com/danmuking/image/main/2395e358eb774d977b5d8b070755120b.jpeg)
让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
### 3. 复制
将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
![](https://raw.githubusercontent.com/danmuking/image/main/90d036e19afb2052b9d89d8bfe2e0e93.jpeg)
主要不足是只使用了内存的一半。
现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。
HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。
### 4. 分代收集
现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。
一般将堆分为新生代和老年代。

- 新生代使用: 复制算法
- 老年代使用: 标记 - 清除 或者 标记 - 整理 算法
#### 为什么要分代
1）弱分代假说：绝大多数对象的生命周期都很短，绝大多数的对象都是朝生夕灭的。
2）强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。
根据这两条假说，jvm的开发者提出了分代回收理论。分代回收理论简单来说就是可以根据对象的年龄（年龄指的是熬过垃圾回收的次数），划分不同的区域，分区存储回收不同年龄的对象。这样做有什么好处呢？想象一下，如果一个区域里全都是新创建的对象，根据弱分代假说，这些对象里的绝大多数很快将消亡，需要被回收。这时候只要关注少数还存活的对象，将这些对象移动到其他区域，然后就可以将这个区域的对象全部回收了。这样的做法效率很高。
## 垃圾收集器
![](https://raw.githubusercontent.com/danmuking/image/main/351162fb45b3c4d35a422bf1384fb40c.jpeg)
以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程: 单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；
- 串行与并行: 串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。
### 1. Serial 收集器
![](https://raw.githubusercontent.com/danmuking/image/main/4d1bcd23c822ee8b3ec91b421a9d8adf.jpeg)Serial 翻译为串行，也就是说它以串行的方式执行。
它是单线程的收集器，只会使用一个线程进行垃圾收集工作。
它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。
### 2. ParNew 收集器
![](https://raw.githubusercontent.com/danmuking/image/main/31f18912b4ea25c8a4d09f93af6ba67c.jpeg)
它是 Serial 收集器的多线程版本。
是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。
默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。
### 3. Parallel Scavenge 收集器
与 ParNew 一样是多线程收集器。
其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。
停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。
可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
### 4. Serial Old 收集器
![](https://raw.githubusercontent.com/danmuking/image/main/185fa6c28327542850ebfe64e8abc980.jpeg)是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途:

- 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。
### 5. Parallel Old 收集器
![](https://raw.githubusercontent.com/danmuking/image/main/b1b27fb160e88c3c22c0e376ddc40fe2.jpeg)
是 Parallel Scavenge 收集器的老年代版本。
在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。
### 6. CMS 收集器
CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。
![](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fgitee.com%2Fvectorx%2FImageCloud%2Fraw%2Fmaster%2Fimg%2F20210512201243.png&sign=58fa83846c183bca27bd6679a78803e261ed896dd745300820b6db31f7851907#from=url&id=hpFHX&originHeight=328&originWidth=1061&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)
分为以下四个流程:

- 初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除: 不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。
具有以下缺点:

- 吞吐量低: 低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
### G1 收集器
G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。
堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
![](https://raw.githubusercontent.com/danmuking/image/main/95b7a94325e02e39c48a3f28b16afe4d.png)G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。
![](https://raw.githubusercontent.com/danmuking/image/main/82572985f4904ebe2bc24abf260bcded.png)
通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。
![](https://raw.githubusercontent.com/danmuking/image/main/c21e1ead8fdee79f23a480abda314c3d.jpeg)
如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:

- 初始标记
- 并发标记
- 最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点:

- 空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。
## 内存分配与回收策略
### Minor GC、Major GC、Full GC
JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。
针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）

- 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 
   - 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
   - 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 
      - 目前，只有 CMS GC 会有单独收集老年代的行为
      - 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收
   - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 
      - 目前只有 G1 GC 会有这种行为
- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾
### 内存分配策略
#### 1. 对象优先在 Eden 分配
大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。
#### 2. 大对象直接进入老年代
大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
#### 3. 长期存活的对象进入老年代
为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
-XX:MaxTenuringThreshold 用来定义年龄的阈值。
#### 4. 动态对象年龄判定
虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
#### 5. 空间分配担保
在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。
### Full GC 的触发条件
对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:
#### 1. 调用 System.gc()
只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
#### 2. 老年代空间不足
老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。
#### 3. 空间分配担保失败
使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第五小节。
#### 4. JDK 1.7 及以前的永久代空间不足
在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
#### 5. Concurrent Mode Failure
执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。

## 参考资料
[GC的前置工作，聊聊GC是如何快速枚举根节点的 - Booksea - 博客园](https://www.cnblogs.com/booksea/p/17646096.html)
