## 1. 概述
G1垃圾回收器是在Java7 update 4之后引入的一个新的垃圾回收器。G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。G1回收器和CMS比起来，有以下不同：

- G1垃圾回收器是**compacting**的，因此其回收得到的空间是连续的。这避免了CMS回收器因为不连续空间所造成的问题。如需要更大的堆空间，更多的floating garbage。连续空间意味着G1垃圾回收器可以不必采用空闲链表的内存分配方式，而可以直接采用bump-the-pointer的方式；
- G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。**内存的回收是以region作为基本单位的**；
- G1还有一个及其重要的特性：**软实时**（soft real-time）。所谓的实时垃圾回收，是指在要求的时间内完成垃圾回收。“软实时”则是指，用户可以指定垃圾回收时间的限时，G1会努力在这个时限内完成垃圾回收，但是G1并不担保每次都能在这个时限内完成垃圾回收。通过设定一个合理的目标，可以让达到90%以上的垃圾回收时间都在这个时限内。

在G1之前的垃圾回收器，如Parallel Scavenge、Parallel Old、CMS等，主要针对Java堆内存中的特定部分(新生代或老年代)进行操作。然而，G1将Java堆划分为多个「**小区域**」，并根据每个区域中垃圾对象的数量和大小来优先进行垃圾回收。
称之为「**基于Region的内存布局**」。
另外设计者们设计G1的时候希望G1能够建立起「**停顿时间模型**」，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。
所以我们能够总结出G1身上的两个标签：

- 基于Region的内存布局
- 停顿时间模型

先来说说基于内存布局是怎么个事儿。
![](https://raw.githubusercontent.com/danmuking/image/main/d75ba85d47187f7571d27d1d630ac667.jpeg)
## G1 GC术语Overview
### PLAB
Promotion Local Allocation Buffers，对象晋升到survivor分区或者老年代分区的过程是在GC线程的晋升本地分配缓冲区（PLAB）进行的，每个线程有独立的PLAB。作用是避免多线程竞争相同数据。和下面介绍的TLAB思想是一致的
### TLAB
Thread Local Allocation Buffers，线程本地分配缓存。**JVM使用了TLAB这种线程专属的区间来避免多线程冲突（无锁方式），提高对象分配效率。**TLAB本身占用了Eden空间，即JVM会为每一个线程都分配一块TLAB空间
![](https://raw.githubusercontent.com/danmuking/image/main/daf2ff0af11e54f297746724d6fb07a4.png)
## 基于Region的堆内存布局
G1的基于Region的堆内存布局，这是能够建立起「**停顿时间模型**」的关键。
**G1逻辑上分代，但是物理上不分代。**
**G1不再坚持固定大小以及固定数量的分代区域划分**，而是把连续的Java堆划分为多个大小相等的独立区域，每一个区域称之为「**Region**」。
![](https://raw.githubusercontent.com/danmuking/image/main/6d23bcfbb3984151cac95a5e2150081d.png)
每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。
**好比角色扮演，不同的角色拿着不同的剧本**。
G1可以通过参数控制新生代内存的大小：-XX:G1NewSizePercent(默认等于5)，-XX:G1MaxNewSizePercent(默认等于60)。
也就是说新生代大小默认占整个堆内存的 5% ~ 60%。
G1收集器将整个Java堆划分成约「**2048个大小相同的独立Region块**」，每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。
**可以简单推算一下，G1能管理的最大内存大约 32MB * 2048 = 64G左右。**
Region中还有一类特殊的「**Humongous区域**」，专门用来存储大对象，可以简单理解为对应着老年代。
**G1认为只要大小超过了一个Region容量一半的对象（即超过1.5个region）即可判定为大对象。**
而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中。
G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。
分配大对象的时候，因为占用空间太大，可能会过早发生GC停顿。G1在每次分配大对象的时候都会去检查当前堆内存占用是否超过初始堆占用阈值IHOP(The Initiating Heap Occupancy Percent)，缺省情况是Java堆内存的45%。当老年代的空间超过45%，G1会启动一次混合周期。
#### 本地分配缓冲 Local allocation buffer (Lab)
值得注意的是，由于分区的思想，每个线程均可以"认领"某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Lab)。
其中，应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，因此TLAB的分区属于Eden空间；而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。
## 可预测的停顿时间模型
**基于Region的停顿时间模型是G1能够建立可预测的停顿时间模型的前提。**
G1将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
**G1收集器会去跟踪各个Region里面的垃圾堆积的「价值」大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表。**
**每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是「Garbage First」名字的由来。**
这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。
所以说G1实现可预测的停顿时间模型的关键就是Region布局和优先级队列。看起来好像G1的实现也不复杂，但是其实有许多细节是需要考虑的。
![](https://raw.githubusercontent.com/danmuking/image/main/fa04113689581d8d9e9f4877785d740c.jpeg)
## 跨Region引用对象
首先第一个问题：**G1将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？**
本质上还是我们之前提过的「**跨代引用**」问题，解决方案的思路我们已经知道，使用「**记忆集**」。
G1的记忆集在存储结构的本质上是一种「哈希表」，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。
使用记忆集固然没啥毛病，但是麻烦的是，G1的堆内存是以Region为基本回收单位的，所以它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。
由于Region数量较多，每个Region都维护有自己的记忆集，光是存储记忆集这块就要占用相当一部分内存，**G1比其他圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。**
这可以说是G1的缺陷之一。
除了跨代引用外，对象引用关系改变，如何解决？
## 对象引用关系改变
解决的办法我们之前在讲「三色标记算法」的时候提过，G1使用「原始快照」来解决这一问题。
垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建。
**G1为每一个Region设计了两个名为「TAMS（Top at Mark Start）」的指针。**
**把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。**
与CMS中的「**Concurrent Mode Failure**」失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间Stop The World。
G1可以通过-XX:MaxGCPauseMillis参数设置垃圾收集的最大停顿时间的JVM参数，单位为毫秒。
在垃圾收集过程中，**G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本**，并分析得出平均值、标准偏差、置信度等统计信息。
然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高的收益。
G1收集器会根据这个设定值进行自我调整以尽量达到这个暂停时间目标。例如，如果设定了-XX:MaxGCPauseMillis=200，那么JVM会尽力保证大部分（但并非全部）的GC暂停时间不会超过200毫秒。
## 运作过程

1. 初始标记（Initial Marking）：**仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值**，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
2. 并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。**当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象**。
3. 最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。
4. 筛选回收（Live Data Counting and Evacuation）：**负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划**，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

**从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的。**
**G1在逻辑上仍然采用了分代的思想，从整体来看是基于「标记-整理」算法实现的收集器，但从局部（两个Region之间）上看又是基于「标记-复制」算法实现。**
![](https://raw.githubusercontent.com/danmuking/image/main/8270d08f299b895f9d302a803d402a50.png)
这时候有些点子王可能会想，如果我把-XX:MaxGCPauseMillis，调的非常小，那是不是就回收的更快了？
![](https://raw.githubusercontent.com/danmuking/image/main/c00468b4d9d90eb109de00d8c527a656.jpeg)
G1默认的停顿目标为两百毫秒，但如果我们把停顿时间调得非常低，譬如设置为二十毫秒，很可能出现的结果就是由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，**收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积。**
**应用运行时间一长，最终占满堆引发Full GC反而降低性能，所以通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。**
## **G1垃圾回收器的回收过程**

**G1GC的垃圾回收过程主要包括如下三个环节：**

- ** 年轻代GC（Young GC） **
- ** 老年代并发标记过程（Concurrent Marking） **
- ** 混合回收（Mixed GC）
（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。） **

![](https://raw.githubusercontent.com/danmuking/image/main/e8f79c3cdeb0969981703f7a026cf581.png)

**顺时针，Young gc -> Young gc + Concurrent mark->Mixed GC顺序，进行垃圾回收。**
**应用程序分配内存，****当年轻代的Eden区用尽时开始年轻代回收过程****；G1的年轻代收集阶段是一个****并行的独占式****收集器。在年轻代回收期，G1GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后****从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及****。**
**当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。**
**标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，****G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了****。同时，这个老年代Region是和年轻代一起被回收的。**
### **Remembered Set**

- ** 一个对象被不同区域引用的问题 **
- ** 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ **
- ** 在其他的分代收集器，也存在这样的问题（而G1更突出）回收新生代也不得不同时扫描老年代？ **
- ** 这样的话会降低MinorGC的效率； **

**解决方法：**
**无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：**
**每个Region都有一个对应的Remembered Set；**
**每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；**
**然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；**
**如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；**
**当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。**

![](https://raw.githubusercontent.com/danmuking/image/main/c97de4bdada1da5a9fdd344692ed0957.png)

### **G1回收过程一：年轻代GC**

**JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。**
**年轻代垃圾回收只会回收Eden区和Survivor区。**
**首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。**

![](https://raw.githubusercontent.com/danmuking/image/main/f29fa4dfe3abf4a77be06fdf3378aecf.png)
![image.png](https://raw.githubusercontent.com/danmuking/image/main/02ee9877609f74da65a9e78718d8fb2b.png)
**然后开始如下回收过程：**

1. **第一阶段，扫描根****。根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。**
2. **第二阶段，更新RSet****。处理dirty card queue（见备注）中的card，更新RSet。此阶段完成后，****RSet可以准确的反映老年代对所在的内存分段中对象的引用****。**
3. **第三阶段，处理RSet****。识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。**
4. **第四阶段，复制对象****。此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。**
5. **第五阶段，处理引用****。处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。**

### **G1回收过程二：并发标记过程**

1. **初始标记阶段****：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。**
2. **根区域扫描（Root Region Scanning）****：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在YoungGC之前完成。**
3. **并发标记（Concurrent Marking）****：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被YoungGC中断。在并发标记阶段，****若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收****。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。**
4. **再次标记（Remark）****：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。**
5. **独占清理（cleanup，STW）****：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集**
6. **并发清理阶段****：识别并清理完全空闲的区域。**

### **G1回收过程三：混合回收**

**当越来越多的对象晋升到老年代o1d region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：****是一部分老年代，而不是全部老年代****。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。**

![](https://raw.githubusercontent.com/danmuking/image/main/766b882cba7e709202005a3baeb596d0.png)

**并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过**`**-XX:G1MixedGCCountTarget**`**设置）被回收**
**混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。**
**由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，**`**-XX:G1MixedGCLiveThresholdPercent**`**，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。**
**混合回收并不一定要进行8次。有一个阈值**`**-XX:G1HeapWastePercent**`**，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。**
### **回收可选的过程四：Full GC**
**G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。**
**要避免Full GC的发生，一旦发生需要进行调整。什么时候会发生Full GC呢？比如****堆内存太小****，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。**
**导致G1 Full GC的原因可能有两个：**

- **Evacuation的时候没有足够的to-space来存放晋升的对象；**
- **并发处理过程完成之前空间耗尽。**
## CMS VS G1
![](https://raw.githubusercontent.com/danmuking/image/main/5e8a4feed0a34d7a83cf6ee326b400cb.png)
相比CMS，G1的优点有很多，**较为明显的优点就是G1不会产生垃圾碎片**。
But，G1相对于CMS仍然不是占全方位、压倒性优势的，至少G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。
**就内存占用来说，虽然G1和CMS都使用卡表来处理跨代指针，但G1的每个Region都必须有一份卡表，这导致G1的记忆集可能会占整个堆容量的20%乃至更多的内存空间，相比起来CMS的卡表就相当简单，全局只有一份。**
在执行负载的角度上，譬如它们都使用到写屏障，CMS用写后屏障来更新维护卡表；而G1除了使用写后屏障来进行同样的卡表维护操作外，**为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况。**
相比起增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。
**由于G1对写屏障的复杂操作要比CMS消耗更多的运算资源，所以CMS的写屏障实现是直接的同步操作，而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理。**
目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，**这个优劣势的Java堆容量平衡点通常在6GB至8GB之间。**
## 参考资料
[GC - Java 垃圾回收器之G1详解](https://pdai.tech/md/java/jvm/java-jvm-gc-g1.html#_1-%E6%A6%82%E8%BF%B0)
[13. 垃圾回收器](https://www.yuque.com/u21195183/jvm/kpugvm?view=doc_embed&inner=424ea84e)
[08 大厂面试题：有了 G1 还需要其他垃圾回收器吗？](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%AE%8C/08%20%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%9C%89%E4%BA%86%20G1%20%E8%BF%98%E9%9C%80%E8%A6%81%E5%85%B6%E4%BB%96%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%90%97%EF%BC%9F.md)
[https://www.cnblogs.com/GrimMjx/p/12234564.html](https://www.cnblogs.com/GrimMjx/p/12234564.html)
[translation/tiemao_2014/G1/G1.md at master · cncounter/translation](https://github.com/cncounter/translation/blob/master/tiemao_2014/G1/G1.md)
[深入理解JVM - G1收集器](https://segmentfault.com/a/1190000040380320)
[https://www.cnblogs.com/booksea/p/17665458.html](https://www.cnblogs.com/booksea/p/17665458.html)
