## 涉及到的名词
### 脏读
脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。
### 不可重复读
不可重复读指的是在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。
### 幻读
select 某记录是否存在，不存在（实际上在数据库中存在，但是在当前隔离级别下无法获取），准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。
比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。
## 什么是事务隔离级别
**事务隔离级别是对事务 4 大特性中隔离性的具体体现，使用事务隔离级别可以控制并发事务在同时执行时的某种行为。**
比如，有两个事务同时操作同一张表，此时有一个事务修改了这张表的数据，但尚未提交事务，那么在另一个事务中，要不要（或者说能不能）看到其他事务尚未提交的数据呢？
这个问题的答案就要看事务的隔离级别了，不同的事务隔离级别，对应的行为模式也是不一样的（有些隔离级别可以看到其他事务尚未提交的数据，有些事务隔离级别看不到其他事务尚未提交的数据），这就是事务隔离级别的作用。
## Spring 事务隔离级别
Sping 中的事务隔离级别有 5 种，它们分别是：
### DEFAULT：
Spring 中默认的事务隔离级别，以连接的数据库的事务隔离级别为准；
### READ_UNCOMMITTED：
读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读
### READ_COMMITTED：
读已提交，也叫提交读，该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读；
### REPEATABLE_READ：
可重复读，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）；
### SERIALIZABLE：
串行化，最高的事务隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。
所以，**相比于 MySQL 的事务隔离级别，Spring 中多了一种 DEFAULT 的事务隔离级别**。
事务隔离级别与问题的对应关系如下：
![](https://raw.githubusercontent.com/danmuking/image/main/77ac36ae8b9b4afcd7c82957e9fb3dc3.png)
