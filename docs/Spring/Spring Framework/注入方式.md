### 1.属性注入
**属性注入是我们最熟悉，也是日常开发中使用最多的一种注入方式**，它的实现代码如下：
```javascript
@RestController
public class UserController {
    // 属性对象
    @Autowired
    private UserService userService;

    @RequestMapping("/add")
    public UserInfo add(String username, String password) {
        return userService.add(username, password);
    }
}
```
#### 1.1 优点分析
**属性注入最大的优点就是实现简单、使用简单**，只需要给变量上添加一个注解（@Autowired），就可以在不 new 对象的情况下，直接获得注入的对象了（这就是 DI 的功能和魅力所在），所以它的优点就是使用简单。
#### 1.2 缺点分析
然而，属性注入虽然使用简单，但也存在着很多问题，甚至编译器 Idea 都会提醒你“不建议使用此注入方式”，Idea 的提示信息如下： 
![](https://raw.githubusercontent.com/danmuking/image/main/56ccaaf60f797b5e0238683665e0d6d4.png)
属性注入的缺点主要包含以下 3 个：

1. 功能性问题：无法注入一个不可变的对象（final 修饰的对象）；
2. 通用性问题：只能适应于 IoC [容器](https://cloud.tencent.com/product/tke?from_column=20065&from=20065)；
3. 设计原则问题：更容易违背单一设计原则。

接下来我们一一来看。
##### 缺点1：功能性问题
**使用属性注入无法注入一个不可变的对象（final 修饰的对象）**，如下图所示： 
![](https://raw.githubusercontent.com/danmuking/image/main/5197f140e291b2c9b77293962f926f58.png)
原因也很简单：**在 Java 中 final 对象（不可变）要么直接赋值，要么在构造方法中赋值，所以当使用属性注入 final 对象时，它不符合 Java 中 final 的使用规范，所以就不能注入成功了。**
PS：如果要注入一个不可变的对象，要怎么实现呢？使用下面的构造方法注入即可。 
##### 缺点2：通用性问题
**使用属性注入的方式只适用于 IoC 框架（容器）**，如果将属性注入的代码移植到其他非 IoC 的框架中，那么代码就无效了，所以属性注入的通用性不是很好。
##### 缺点3：设计原则问题
使用属性注入的方式，因为使用起来很简单，所以开发者很容易在一个类中同时注入多个对象，而这些对象的注入是否有必要？是否符合程序设计中的单一职责原则？就变成了一个问题。 但可以肯定的是，**注入实现越简单，那么滥用它的概率也越大，所以出现违背单一职责原则的概率也越大**。 注意：**这里强调的是违背设计原则（单一职责）的可能性，而不是一定会违背设计原则**，二者有着本质的区别。
### 2.Setter 注入
Setter 注入的实现代码如下：
```javascript
@RestController
public class UserController {
    // Setter 注入
    private UserService userService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    @RequestMapping("/add")
    public UserInfo add(String username, String password) {
        return userService.add(username, password);
    }
}
```
#### 优缺点分析
从上面代码可以看出，Setter 注入比属性注入要麻烦很多。 **要说 Setter 注入有什么优点的话，那么首当其冲的就是它完全符合单一职责的设计原则，因为每一个 Setter 只针对一个对象**。 但它的缺点也很明显，它的缺点主要体现在以下 2 点：

1. 不能注入不可变对象（final 修饰的对象）；
2. 注入的对象可被修改。

接下来我们一一来看。
##### 缺点1：不能注入不可变对象
使用 Setter 注入依然不能注入不可变对象，比如以下注入会报错： 
![](https://raw.githubusercontent.com/danmuking/image/main/26616a627b35e1e1ee148ec392ec2162.png)
##### 缺点2：注入对象可被修改
Setter 注入提供了 setXXX 的方法，意味着你可以在任何时候、在任何地方，通过调用 setXXX 的方法来改变注入对象，所以 **Setter 注入的问题是，被注入的对象可能随时被修改**。
### 3.构造方法注入
**构造方法注入是 Spring 官方从 4.x 之后推荐的注入方式**，它的实现代码如下：
```javascript
@RestController
public class UserController {
    // 构造方法注入
    private UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }

    @RequestMapping("/add")
    public UserInfo add(String username, String password) {
        return userService.add(username, password);
    }
}
```
当然，**如果当前的类中只有一个构造方法，那么 @Autowired 也可以省略**，所以以上代码还可以这样写：
```javascript
@RestController
public class UserController {
    // 构造方法注入
    private UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @RequestMapping("/add")
    public UserInfo add(String username, String password) {
        return userService.add(username, password);
    }
}
```
#### 优点分析
构造方法注入相比于前两种注入方法，它可以注入不可变对象，并且它只会执行一次，也不存在像 Setter 注入那样，被注入的对象随时被修改的情况，它的优点有以下 4 个：

1. 可注入不可变对象；
2. 注入对象不会被修改；
3. 注入对象会被完全初始化；
4. 通用性更好。

接下来我们一一来看。
##### 优点1：注入不可变对象
使用构造方法注入可以注入不可变对象，如下代码所示： 
![](https://raw.githubusercontent.com/danmuking/image/main/d8932b3665f29b19c11b83730d38a7d4.png)
##### 优点2：注入对象不会被修改
构造方法注入不会像 Setter 注入那样，**构造方法在对象创建时只会执行一次，因此它不存在注入对象被随时（调用）修改的情况。**
##### 优点3：完全初始化
因为依赖对象是在构造方法中执行的，而构造方法是在对象创建之初执行的，因此被注入的对象在使用之前，会被完全初始化，这也是构造方法注入的优点之一。
##### 优点4：通用性更好
构造方法和属性注入不同，构造方法注入可适用于任何环境，无论是 IoC 框架还是非 IoC 框架，构造方法注入的代码都是通用的，所以它的通用性更好。

## 参考资料
[面试突击77：Spring 依赖注入有几种？各有什么优缺点？-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2119997)
