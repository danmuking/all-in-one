## **OAuth 认证**
OAuth 认证比较常见的就是微信登录、微博登录、qq登录等，简单来说就是利用这些比较权威的网站或应用开放的 API 来实现用户登录，用户可以不用在你的网站或应用上注册账号，直接用已有的微信、微博、qq 等账号登录。
这一样一来，即省了用户注册的时间，又简化了你的系统的账号体系。从而既可以提高用户注册率可以节省开发时间，同时，安全性也有了保障。
维基百科对它的解释摘要如下：
OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。
假设我们开发了一个电商平台，并集成了微信登录，以这个场景为例，说一下 OAuth 的工作原理。
讲之前需要了解其中涉及到的几个角色：

- 用户：即使用我们平台的用户
- 用户终端：即最终用户使用的 APP 端或 web 端
- 应用服务器端：即我们的服务器端
- 授权服务器端：这里就是微信处理授权请求的服务器

好的，接下来开始在我们的电商平台web端实现微信登录功能。微信网页授权是授权码模式（authorization code）的 OAuth 授权模式。

1. 我们电商平台的用户过来登录，常用场景是点击“微信登录”按钮；
2. 接下来，用户终端将用户引导到微信授权页面；
3. 用户同意授权，应用服务器重定向到之前设置好的 **redirect_uri** （应用服务器所在的地址），并附带上授权码（code）;
4. 应用服务器用上一步获取的 code 向微信授权服务器发送请求，获取 **access_token**，也就是上面说的令牌；
5. 之后应用服务器用上一步获取的 **access_token** 去请求微信授权服务器获取用户的基本信息，例如头像、昵称等；
## **Cookie-Session 认证**
早期互联网以 web 为主，客户端是浏览器，所以 Cookie-Session 方式最那时候最常用的方式，直到现在，一些 web 网站依然用这种方式做认证。
**认证过程大致如下：**

1. 用户输入用户名、密码或者用短信验证码方式登录系统；
2. 服务端验证后，创建一个 Session 信息，并且将 SessionID 存到 cookie，发送回浏览器；
3. 下次客户端再发起请求，自动带上 cookie 信息，服务端通过 cookie 获取 Session 信息进行校验；

**弊端**

- 只能在 web 场景下使用，如果是 APP 中，不能使用 cookie 的情况下就不能用了；
- 即使能在 web 场景下使用，也要考虑跨域问题，因为 cookie 不能跨域；
- cookie 存在 CSRF（跨站请求伪造）的风险；
- 如果是分布式服务，需要考虑 Session 同步问题；
## **Cookie-Session 改造版**
由于传统的 Cookie-Session 认证存在诸多问题，可以把上面的方案改造一下。改动的地方如下：

- 不用 cookie 做客户端存储，改用其他方式，web 下使用 local storage，APP 中使用客户端数据库，这样就实现了跨域，并且避免了 CSRF ;
- 服务端也不存 Session 了，把 Session 信息拿出来存到 Redis 等内存数据库中，这样即提高了速度，又避免了 Session 同步问题；

经过改造之后变成了如下的认证过程：

1. 用户输入用户名、密码或者用短信验证码方式登录系统；
2. 服务端经过验证，将认证信息构造好的数据结构存储到 Redis 中，并将 key 值返回给客户端；
3. 客户端拿到返回的 key，存储到 local storage 或本地数据库；
4. 下次客户端再次请求，把 key 值附加到 header 或者 请求体中；
5. 服务端根据获取的 key，到 Redis 中获取认证信息；
## **基于JWT的Token认证**
上面的方案虽然经过了改版，但还是需要客户端和服务器端维持一个状态信息，比如用 cookie 换 session ,或者用 key 换 Redis 的 value 信息，基于 JWT 的 Token 认证方案可以省去这个过程。
JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。
**认证过程**

1. 依然是用户登录系统；
2. 服务端验证，将认证信息通过指定的算法（例如HS256）进行加密，例如对用户名和用户所属角色进行加密，加密私钥是保存在服务器端的，将加密后的结果发送给客户端，加密的字符串格式为三个"." 分隔的字符串 Token，分别对应**头部**、**载荷**与**签名**，头部和载荷都可以通过 base64 解码出来，签名部分不可以；
3. 客户端拿到返回的 Token，存储到 local storage 或本地数据库；
4. 下次客户端再次发起请求，将 Token 附加到 header 中；
5. 服务端获取 header 中的 Token ，通过相同的算法对 Token 中的用户名和所属角色进行相同的加密验证，如果验证结果相同，则说明这个请求是正常的，没有被篡改。这个过程可以完全不涉及到查询 Redis 或其他存储；

**优点**

- 使用 json 作为数据传输，有广泛的通用型，并且体积小，便于传输；
- 不需要在服务器端保存相关信息；
- jwt 载荷部分可以存储业务相关的信息（非敏感的），例如用户信息、角色等；
## 双token方案
双token是为了**解决jwt的续期**问题的。由于jwt一颁布，就意味着在指定时间内能够通行。

1. 如果给的有**效期过长**，风险是比较大的，服务器失去了掌控力。在这期间如果想让用户失效，或者是有人盗取了token。都可以胡作非为好久。`refresh_token`要求于ip或者ua信息进行强绑定，被盗取后失效。
2. 如果给的有**效期过短**，用户经常需要重新登录，体验也很不好。
3. 如果**中心化管理**用户状态，也就是每次解析jwt token之后，还需要去中心化比对能否通过。这样又违背了初衷。增加每次**认证的耗时**
4. 降低认证服务器的压力，因为 access_token 可以由各个业务服务自己去认证（比如服务共享私钥），只有在 access_token 过期的时候，流量才会打到 认证服务器

双token分为`access_token`和`refresh_token`。一般`access_token`的有效期可以设置为10分钟，`refresh_token`的有效期可以设置为7天。用户每次请求都用`access_token`，如果前端发现请求401，也就是过期了，就用`refresh_token`去重新申请一个`access_token`。继续请求。
这里的关键在于，`refresh_token`申请`access_token`的时候，用户是无感知的，前后端的框架自动去更新这个新的`access_token`。
还有一个点在申请`access_token`的时候，后端这时候会去校验用户的状态等问题，如果发现用户被禁用了，就申请不到token了。
### 总结
双token是一个多方平衡的完美方案。它希望对用户的认证有所**掌控**，又不希望每次的检验会增加**耗时**。它不想给用户**过长的授权时间**，又不想用户因此**频繁登录**影响体验。因此变成了每隔一段`access_token`的过期时间，都会重新掌控局面，进行重新认证的复杂判断。
