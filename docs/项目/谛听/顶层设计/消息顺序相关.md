## 消息时序性
消息时序性，主要解决的就是消息展示的顺序问题。它为啥那么难？
如果用户a给用户b同时发了三条消息 aa bb cc。而服务端接收到的消息是并发的，可能入库就是aa cc bb。
就产生了发送方顺序和接收方顺序不一致的情况。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/e65c707a86ae88192da686b0da42f24b.png)
### 客户端排序
这时候可以让a发送的每条消息带上时间戳，服务存储a的消息时间戳。b的展示根据时间戳排序。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/d056a5d3f5678d439b2aac84813b73eb.png)
但是如果在多端发送的情况下，a有电脑端，手机端，**每个端的时间**可能是不一样的，就会出现发送的乱序问题
![image.png](https://raw.githubusercontent.com/danmuking/image/main/f74157c891b6af0f5a59d119f4464e60.png)
回头想想，只是为了解决用户快速发两三条消息时间内的**局部排序**而已。可以参考[腾讯sdk](https://cloud.tencent.com/document/product/269/2282)的实现。
给消息设置一个本地的自增id，发送消息的时候带上。排序整体以服务器的时间为准，相同秒内的排序以自增id为准。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/1fe2831ff7b5e80bcd7d45ddecffc949.png)
这样赌的就是，你发的消息再快，哪怕存储顺序变了，但是也都在1s内，对于b来说，1s内的消息，按照自增id额外排序就好了。
这样发送者只需要保证指定时间内的消息自增就好。如果哪天seq丢失，或者在其他端发消息seq不一致，都没关系。
但是在群聊的场景下，每个群成员的客户端时间也是不一样的，没法作为排序的统一基准时间。只能采用服务端时间。并且seq也是不同的，相同秒内也没法排序，不适用该方案
![image.png](https://raw.githubusercontent.com/danmuking/image/main/ba4cf5104b833cbde19cdce0e5900420.png)
### 服务端排序
对于群聊的场景，我们需要采用服务端排序。服务端排序其实本应该很简单。
对于单表来说，我们可以采用**主键id**来排序，也可以通过**消息的时间戳**来排序。id肯定是严格自增了，时间戳要考虑**精度问题**，一般设置的精度是毫秒，也基本足够进行消息的排序了。因为毫秒内的消息，本身就没有上下文的关系，对顺序要求不高。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/53b0cd4ba5c21c12122ff123aa9c0438.png)
小绿小王小马，他们的消息还在发送中，互相都是根据上面已发的消息做的决策，所以他们三的顺序，并不重要，以服务端的时间为准即可。
除了消息的**顺序性**外，还有一个很重要的点，就是消息的**唯一性**。在[游标翻页](https://www.yuque.com/snab/mallchat/kf0dtv51houe86nh)的场景下。翻页的游标字段，需要同时保证顺序性与唯一性的作用。如果单纯用时间戳，毫秒内的消息，就没办法区分与排序，得额外再拼接其他唯一字段一同排序，不如就直接用唯一且有序的id作为游标。
![](https://raw.githubusercontent.com/danmuking/image/main/3508a3e7938912149eb92b80613db601.png)
因此消息的时序性，我们通常都是用一个唯一id来保证。[微信sdk](https://cloud.tencent.com/document/product/269/2738)也是用一个id来进行翻页。

### 总结
通常没有绝对的客户端排序，单聊场景可以用客户端seq。保证单位时间内多条消息的顺序性。
消息不仅要保证时序性，也要保证唯一性。通常用消息id一个字段满足两个需求。

## 消息id
消息id被我们给予厚望，不仅要**唯一**，还要**有序**（递增）
保证唯一很简单，随便一个分布式id都能实现。重点是消息的有序，如何去保证。
### 全局递增
消息在整个IM系统都是唯一且递增的。一般对于单表来说**主键**就自然保证了递增。但是如果消息量大了，省不了分库分表，分库分表后的消息递增，通常采用分布式id。但是分布式id通常保证的是**趋势递增**，而不是**单调递增**。
![](https://raw.githubusercontent.com/danmuking/image/main/f5232e2ea6c50976d4b7d28c5770cf7e.png)![](https://raw.githubusercontent.com/danmuking/image/main/e177f7e7d04e727c421009acf5dfc32e.png)
所以雪花id不适用于IM这种严格时序性的系统。对分布式id感兴趣可看《架构之路》的[分布式id方案](https://www.yuque.com/snab/architecture/crefklebmccw1vpr)文章
事实上，**严格的单调递增**，意味着**严重的单点竞争**问题。对于一个都需要分库分表的系统，是很难实现这样的方案的
### 会话级别递增
上面也说到，全局的单调递增，意味着严重的单点竞争。话说回来，我们为啥需要递增呢？不就是为了消息的顺序性展示吗？只需要保证单个群组内的消息id是有序的且唯一的，就足够了。QQ就是这样的架构。
那么如何保证会话级别的递增呢？一个简单的做法分库分表**以会话id分表**。这样相同的会话必定在同一张表，又重新用回了**主键自增**。
一般分表就不用主键自增了，都是用分布式id。因为这种方案很难支持之后的扩容，比如4扩8。
用**分布式id**保证会话级别的单调递增
**单调递增**，同时意味着**单点问题。**两者是不可两全的。分布式id之所以没有单点问题，所以大多都是趋势递增。这里面涉及的可用性，以及单调递增这种一致性的取舍。非常有意思。最终实现的效果，类似mysql的主从，单点的mysql用于自增id，以及主从保证高可用的切换。实现参考：[微信序列号生成器架构设计](https://cloud.tencent.com/developer/article/1004444)
### 收信箱递增
**会话级别的递增**，更多的适用于**读扩散**的场景。所有人拉取消息列表的时候，都去会话的消息表拉取。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/407bd198033d54f16b42a53730634098.png)
**收信箱的递增**，适用于**写扩散**的场景。所有人都有自己的一个收信箱，维护自己的时间线即可。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/c17ade6b1bb60902c0f42a901ef935a3.png)
收信箱的时间线的单调递增和uid相关。实现的方式和上面都一样，一个是以会话为key，一个是以uid为key。
实现参考：[微信序列号生成器架构设计](https://cloud.tencent.com/developer/article/1004444)
微信就是典型的写扩散场景，所以他的群聊最多只能500人。
### 总结
我们讨论了消息id重要的使命，用来确保唯一，和有序。
对于有序顺带提了单调递增和趋势递增。现实中分布式id大多数都是趋势递增的，这样比较高可用。
而有序，又讨论是三种有序的情况，为啥全局单调递增不好实现（因为单点竞争）。引出了单调递增id生成器的方案，和可用性保证。
如果你能了解市面上大多[分布式id方案](https://www.yuque.com/snab/architecture/crefklebmccw1vpr)的优缺点，同时了解IM的业务诉求，必须单调递增的限制。又能够引出业界的[解决方案](https://cloud.tencent.com/developer/article/1004444)。基本上能折服非该行业的面试官了，同时体现出你的专业性。
说了这么多，虽然抹茶用的就是单表id自增。但是哪怕问到亿级数据的方案，我们也不带怕的！


