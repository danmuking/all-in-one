## 单聊群聊
消息表怎么兼容单聊和群聊。我看市面上很多的设计都是这样的。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/c1d8123875b68d6fc0ce703dd0fec7d1.png)
目标类型分为单聊和群聊。**单聊**的情况下目标id填**uid**。**群聊**情况下，目标id填**群组id**。这样消息是兼容了，但是其他地方也都要兼容了。比如我们的个人收信箱。需要存所有消息。同时还要知道这个消息在哪个会话下的。单聊群聊的会话要怎么去唯一标识呢，首先个人信箱，都需要个人uid去标识。一般单聊是加上好友uid，就代表会话。群聊加上群id。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/7fbd8500ce191c3c86e30bae8908364d.png)
这样收信箱也需要兼容单聊和群聊，设计两个字段，后续为了能快速命中会话，还需要设计**组合索引**。
后续其他表只要是涉及会话id的都需要这两个字段。想想就麻烦。本着复用和抽象的原则。能复用的地方，就给它抽出来，看看我们要怎么去优化它。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/a29c507a6ab72770cb8acc7bd59286a1.png)
我们可以抽象一个房间表出来，群聊所有人在一个房间里面聊天。单聊无非就是两个人在房间里面聊天。这样房间关联上单聊或者群聊的相关信息。有了这层抽象。消息表和个人信箱都不需要两个字段标识会话了。直接用房间id就是会话id。通过房间id，自然就关联出对应的单聊群聊信息了。
[https://drawsql.app/teams/-328/diagrams/-6](https://drawsql.app/teams/-328/diagrams/-6)
![image.png](https://raw.githubusercontent.com/danmuking/image/main/f2180ed0fee4478f5e2161c6b8e424bc.png)
所以表结构设计就是这样的。通过房间表room，抽象了一层，**屏蔽了单聊群聊的差异**，让其他关心会话的表设计起来更加简单。只需要关联一个房间id字段。
**单聊群聊**和**房间**，都是一对一的关系。相当于单聊表和群聊表都是扩展表。本质上是可以直接在room上面添加字段的。选择扩展能划分更加明确。
**群聊**有对应的头像，群名称等。另外还有一个很重要的群成员。由于群成员和群是多对一的关系。一个群可以有多个群成员。
**群成员**单独建了一张表。里面有个role字段，记录群成员在群里的属性，比如群主，管理员，普通成员。如果我们需要快速判断一个群的群主怎么办？为了走索引，所以设计了`group_id和role`的联合索引。当然你也可以作为冗余字段，直接记录在group表，添加个群主uid字段。
**单聊表**有个很重要的点，就是怎么去唯一确认一个房间。比如我新加了一个好友，系统为我们生成了一个单聊房间。后续在好友列表找到这个好友，对他发消息。这时候怎么找到我们之前的那个房间。这时候我只知道我的uid和好友的uid。
所以在单聊表中有两个重要的字段，uid1和uid2代表好友双方的uid。为了能保证双方建立的房间的唯一性。我们增加了一个唯一字段`room_key`来唯一标识两个好友的房间。
他的生成规则很简单。`uid1_uid2`。其中uid1是双方uid较小的那个，uid2是双方uid较大的那个。这样避免不同的排列顺序，产生二义性。
**总结**
上面的设计完全是抹茶的设计。通过抽象一层房间表，来屏蔽单聊群聊的差异，让消息表和会话表的存储变得更加简单。这是后续面试官会无数次问到你的问题。了解其中的背景和方案，让你在后续的面试中能够对答如流。
## 会话列表设计
[https://drawsql.app/teams/-328/diagrams/-7](https://drawsql.app/teams/-328/diagrams/-7)
![image.png](https://raw.githubusercontent.com/danmuking/image/main/4e40f4fe0436122f97de376d25e4ca07.png)
有了这样的设计，我们还能很轻松的实现会话列表的功能。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/36a9daa41c0dbf07911f3da4fe97a7e4.png)
这张会话表，就是用户优化过后的收信箱。来看看怎么靠他实现对应的功能。
会话表记录的是`uid`在某个`room`内的消息详情，比如`最新消息时间`，自己`阅读到的时间`。
会话列表：`select room_id from contact where uid =我  order by active_time desc`。查到我的所有会话，并按照每个会话的最新消息时间倒序排序。为了能快速命中索引，需要`uid和active_time`的联合索引
会话消息未读数：`select count(0) from msg where room_id=我房间 and create_time>我阅读`。拿着自己会话表的阅读时间去消息表比较，由于有`room_id和create_time`的联合索引。查找速度很快。
优化：假设我很多年没上线了。消息的未读数达到了几万条，就算我有索引，也得扫描几万条记录，统计未读数。这个还是比较耗时的，怎么办呢？参考微信最大只展示99条消息的未读数。我们的未读数统计可以优化成
```sql
select count(0) from
(
  SELECT 1
    FROM msg
    WHERE room_id=我房间 and create_time>我阅读
    LIMIT 100
)
```
这样未读数最多只会扫描100条，避免了极端的场景。
抹茶的会话表设计，目前就采用了这样的方案。通过记录阅读**时间线**而不是记录每条**消息的ack**。完美适配了会话列表的功能，和消息已读未读数的功能。
## 热点群聊（读写扩散混合）
前面留了那么多个坑，都依然没有解决万人群聊写扩散的问题。但是通过一步步的表结构设计的优化，已经逐渐接近了。
万人群聊最大的问题，就是每条消息，都需要写入用户的收信箱。也就是那个会话表的`active_time`字段。更新了这个字段，最新消息的那个会话才能排序在最前面。如果不更新，这个房间在用户的会话列表就排在很后面了。
这个更新时间可以记，但是能不能单独记，不扩散写到用户的收信箱，而是单独写到热点信箱，用户读取的时候综合读取自己收信箱的会话，合并热点信箱的会话。
![热点群聊.png](https://raw.githubusercontent.com/danmuking/image/main/c283ff9d5692bdb723f28ce9d1d3ac8f.png)
这样每个小方块都是一个房间，里面的数字代表这房间的最新消息**游标**。

- 对于**小群聊**写扩散到用户的每个收信箱，更新房间的最新消息**游标**。
- 对于**热点群聊**，直接**单独记录**该房间的最新**游标**。
- 用户在查询自己会话列表的时候，通过**聚合层**。聚合自己**收信箱**，和自己参与的**热点群聊**的**排序**，然后展示给用户

这样就可以节省每次热点群聊写扩散的消耗了，对热点群聊来说是个极致的提升。
[https://drawsql.app/teams/-328/diagrams/-7](https://drawsql.app/teams/-328/diagrams/-7)
![image.png](https://raw.githubusercontent.com/danmuking/image/main/e640cc137808ca900be1ca873a977cce.png)
热点群聊相关的信息，直接记录在room表里，不需要写入到用户信箱。
为了**聚合**的时候**效率**更高。我们还可以把热点群聊直接缓存在redis的zset里。这样聚合的时候，速度更快。
### 精确时间聚合
在现实的场景里，跨服务分页一直是一个难题。最佳的方案就是写一张聚合表，将跨库的数据聚合成一张表，然后进行条件分页。然而我们的热点群聊就是为了避免写扩散，所以才需要聚合。这个方案行不通了。
那我们怎么去聚合呢。可以选一张主表用来分页，副表用来聚合。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/7959e601bf41eac938810b2bac702f30.png)

1. 以收信箱为主表，查询第一页,假设一页3条。查到3，5，7，通过3和7作为条件，筛选热点群聊里面的房间，只能筛选到4。2怎么办？？？需要兼容第一页的场景，start不应该限制。只限制end<7，筛选出2和4。聚合返回2，3，4，5，7。

![image.png](https://raw.githubusercontent.com/danmuking/image/main/a52d973b70fb02ac6b1b2a393ad6f394.png)

2. 第二页只有两条，筛选出9和10，通过9和10作为条件，筛选热点群聊房间，筛选不到。那18怎么办？？需要兼容最后一页的场景，end不应该限制，只限制start>9.筛选出18.聚合返回9，10，18.

这种方案性能非常的高，但是需要业务能够接受本来一页三条数据，有可能一页5条，或者一页4条的情况。在极端场景这个人加入了很多热点群聊，一页可能会加载出100多条数据。
### 精确条数聚合
如果业务有强烈的诉求，期望一页得到的条数是固定的3条，我们也需要提供相应的方案来满足诉求。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/64139582909923dadc1e4961de125254.png)

1. 查询第一页的三条，个人收信箱和热点信箱都是主表。双方各查出一页的数据**候选**（避免极端情况一页都是热点，或一页都是普通）。通过归并排序的方式，每次都pk普通和热点的房间，取出较小的那个放到结果集合。第一轮比较取出2，第二轮比较取出3，第三轮比较取出4，填满即可。
> 这个很像一个面试题，大文件排序怎么做？

大文件的难点，在于内存放不下所有的数据。因此只能拆分成一个个局部排序的小文件。然后再对多个小文件，进行**多路归并排序**。
![](https://raw.githubusercontent.com/danmuking/image/main/5035dacee586389061d69c2cc9b364b1.jpeg)
将多个文件的头结点，一起构造一颗小顶堆的树。每次从顶堆取值，就汇总最终的排序。顶堆支持每次弹出一个值就从候选队列再压入一个值。类似的是，我们的抹茶只有两路归并，简单了不少。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/7987f807bf85549413ce0aa1986e0455.png)

2. 查询第二页。根据上一页的最后一条的游标，确定下一页开始的位置，这就是[游标翻页](https://www.yuque.com/snab/mallchat/kf0dtv51houe86nh)。这个场景用普通翻页无法实现。根据上一页的最后一条消息是4，往下双方各查一页。最终通过归并排序，返回结果5，7，9。

这样就是做到精确分页了，他的核心是，id必须全局单调递增。因为每个会话记录的都是最后一条消息的id。这个id是用来排序的，如果id只能做到会话内递增，那不同会话间压根没法比较。
