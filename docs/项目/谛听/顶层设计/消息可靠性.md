      ![image.png](https://raw.githubusercontent.com/danmuking/image/main/c176b3a44ff91286695a74715ee018fd.png) 

- 如果是http协议，他的协议能够在tcp之上，通过收发的报文进行请求和响应的关联。

我们的抹茶，就是用的http来发送消息，通过返回的标识，判断是否发送成功即可。
如果发送方发送失败（ack明确失败，ack超时）如果是明确失败，可能是业务校验问题，提示用户即可。如果是超时，底层帮助自动重发。确保发送可靠。
### 推送可靠
推送可靠一般体现在服务端消息入库成功后。推送给对应的消息接收方。需要保证消息能够到达消息的接收方。
为了保证严格的可靠性，这些推送给每个人的ack都是需要入库的，可以写到每个人的消息表持久化。接收到ack后，修改消息状态。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/7e990d22d9b33fa8ff3cb7b24b25fdc3.png)
`定时重试`：可靠性，基本离不开一个不断check的重试节点。这个重试可能是后端，也可能是前端。如果信箱没有收到ack。说明消息没有到达接收端，需要进行重新推送。可靠的前提，在于信箱是**持久化**的。定时任务又支持**不断重试**的。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/6331c6fd7e55aaadf1716f04286a32e6.png)
但这有个问题，如果用户一直不在线，难道你的定时任务就一直拉取全部信箱消息，在逻辑判断是否在线，再推送吗？这每次拉取的消耗可不小。
`在线推送`：推送服务增加一个判断，如果是在线消息，才会进行推送，并且记录消息在内存中，定时任务也只会拉取内存ack队列的消息，进行推送重试。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/9e35799c94ec526fa5d1042c37ecb6da.png)
如果接收到ack。内存队列会移除对应的待ack消息。并且对持久化的信箱进行ack标识。如果内存待ack队列过多，可以采用lru的方式，排除最早入队的消息。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/25456d548d5457ad1f0a632a7be66f46.png)
当然内存队列是肯定不可靠的，但他只是为了**加速**我们的可靠性推送的效率，最终还有我们的持久化收信箱做兜底。**最后的保障**，也就是我们的离线推送。
`离线推送`：对于不在线的用户，只能确保他在下一次连接上的时候，保证消息的可靠推送。在此之前，还有友情通过push的方式提示他消息到达。让他打开软件。
![cf02610b49dbf3a8c6b737e36a4ff1c.jpg](https://raw.githubusercontent.com/danmuking/image/main/5932d3ddbd5c2d31fe3ebbce04c4461c.jpeg)
![image.png](https://raw.githubusercontent.com/danmuking/image/main/055e7f033f6d8a34f7ead9b95e447e04.png)
所有的复杂点都在用户上线的时间点。发现用户上线后，要立马查出他所有未ack的消息，一股脑全部推送给他。并且copy一份到内存ack队列，确保可靠性。后面的流程就差不多了，定时任务继续重试，保证最终的一致性。
**一次性推送所有消息，也可能会有瓶颈，对于一个很久没上线的用户来说。**
可以做到分批推送，感兴趣看[b站文章](https://mp.weixin.qq.com/s/LSE-8iOwrySuHdHlDK0pXA)。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/8a3ef5c0bae57fa97fdb191fff41ea78.png)
这样已经是一个完整的消息可靠性方案了。做到了持久化，重试，就能达到最终一致性。**但是**。。。
在我们的万人群聊场景下，一条消息，就意味着需要写入1w人的收信箱。你知道这种**写扩散**的系数有多爆炸吗？？？再换个角度来说，每条消息都存一份消息id到用户的个人信箱。对应的存储也增长了好多倍。微信为了降低写扩散的影响，都把群限制了只能500个人。（不是说解决不了，只是代价挺大的）。
以上我们讨论的都是**消息推送的可靠性**，遇到的热点问题，实际上还有一些优化方案，后面的**推拉结合**，和**热点群聊**，都会再讨论这个问题，综合一个更好的方案。
上面的讨论，我们了解了消息可靠的基本方案。虽然抹茶没做到消息的可靠保证，但是面试官问的的时候，你也能答得出来了。
抹茶为啥不做消息可靠的保证呢？一方面是复杂。另一方面抹茶是一个web项目，压根就不存储消息，消息到没到问题不是很大，哪怕消息到了，你刷新一下，消息也又没了。
[http://www.52im.net/thread-3182-1-1.html](http://www.52im.net/thread-3182-1-1.html)
## 消息重复避免
分布式下的一致性方案，我们都老生常谈了。几个关键点，**最终一致性** ，**持久化**，**重试**，**幂等**。在分布式场景下一般为了达到最终一致性，失败了我们也需要进行重试，重试就有幂等问题，如何标明两次重试是一次操作，不能因为重试插入了两条数据。
保证幂等关键的点就是幂等标识。
### 发送消息幂等
消息发送的时候，如果遇到网络波动，底层会自动帮忙重试。如何唯一的标识这条消息？靠的是发送端生成一个唯一的标识，如果重试的时候，相同的消息带的是相同的标识。后端服务就能够检测出来，保证幂等。
类似kafka发消息到broker的重试，也会在发送时生成个幂等标识。[腾讯sdk的文档](https://cloud.tencent.com/document/product/269/2282)，也能看到发送消息的一个随机md5，保证幂等标识。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/af7d86218072a46e980c04fb64cfc308.png)
1s内的去重保证，是比较好的做法。否则需要去重判断的范围太大了，涉及的历史数据也太多了。这样的话，发送端的自动重试也要限制一下超过1s还没成功，就放弃重试了。
### 接收消息幂等
服务端对接收方的消息推送，也是有可靠性保证的。如果没有及时收到ack，定时任务就会进行消息推送重试。同样需要考虑到幂等问题。
假设服务端对接收方推送了相同的消息两次。接收方会怎么展示呢？一般能够想到对消息做幂等判断，如果是客户方已经展示的消息，就跳过。那么这个唯一性怎么判断呢？
消息的唯一性，基本就靠消息id来判断了。上面也讨论了消息id的唯一性问题。一般全局消息唯一的话。直接用唯一消息就好了。
如果是会话级别的消息id唯一，那判断的时候就需要判断`会话id+消息id`唯一。
