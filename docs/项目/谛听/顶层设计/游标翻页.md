两年前，阿斌在面试一家电商公司的时候，被面试官问道深翻页的问题怎么解决。一时没有get到重点，回答的很是一般，到后面进了公司，看见了很多深翻页的场景，解决方案基本都是【游标翻页】。
这次就好好谈谈普通翻页和游标翻页的区别。他们之间的优缺点。
**深翻页问题**
普通翻页前端一般会有个分页条。能够指定一页的**条数**，以及任意选择查看**第几页**。

![](https://raw.githubusercontent.com/danmuking/image/main/c12eb1cb21908520463e6cd2b32fdef5.png)

对应的参数就是pageNo和pageSize

![](https://raw.githubusercontent.com/danmuking/image/main/043558eeb42e4dcb441e867ffbb88051.png)

假设前端想要查看第11页的内容，传的值pageNo=11，pageSize=10
对于数据库的查询语句就是。
其中100代表需要跳过的条数，10代表跳过指定条数后，往后需要再取的条数。

![](https://raw.githubusercontent.com/danmuking/image/main/00f2db0635c173cd8b69bd9b886ba21f.png)

对应图片就是这样的一个效果，需要在数据库的位置先读出100条，然后**丢弃**。丢弃完100条后，再继续取10条**选用**。
如果我们翻页到了很深的地方，比如读到了第1000页，对应的sql语句就是
需要先查询10000条进行丢弃，再取那么个10条选用。这个效率也太低了，
我们经常需要定时任务全量去跑一张表的数据，普通翻页去跑的话，到后面数据量大的时候，就会越跑越慢，这就是深翻页带来的问题。
有没有解决办法呢？有！
好好思考下，目前的问题在于每次翻页都需要花时间扫描一些不需要的记录，然后丢弃。那么是不是可以优化这个步骤呢？
以后不论第几页，我们都不需要跳过一些值。直接取limit 0,10。这样语句变成了
取到的是1-10这些记录，取不到我们想要的101-110.
没关系，再加一个条件

![](https://raw.githubusercontent.com/danmuking/image/main/6fa2234c11ccb2efa23243be8247595d.png)

只要id这个字段有索引，就能直接定位到101这个字段，然后去10条记录。以后无论翻页到多大，通过索引直接定位到读取的位置，效率基本是一样的。这个id>100就是我们的游标，这就是**游标翻页。**
**游标翻页简单介绍**
游标翻页可以完美的解决深翻页问题，依赖的就是我们的游标，即cursor。针对mysql的游标翻页，我们需要通过cursor快速定位到指定记录，意味着游标必须添加索引。

![](https://raw.githubusercontent.com/danmuking/image/main/ce29b45809c55b2eaeb3d720520022df.png)

前端之前传的pageNo字段改成了cursor字段。cursor是上一次查询结果的位置，作为下一次查询的游标，由后端返回,具体交互可看[抹茶的前端后是如何协作的](https://www.yuque.com/snab/mallcaht/me5ydklp9tltg9rd#bA4a1)
我们来模拟一次前后端的翻页交互

![](https://raw.githubusercontent.com/danmuking/image/main/3508a3e7938912149eb92b80613db601.png)

随着翻页的持续，游标不断往翻页的方向推进。
所以游标翻页不适合跳页，只能不断的往下翻。更适合C端的列表场景
**列表变化问题**
这是一个抹茶的消息列表功能，用户往上能够翻页查看历史消息，你会怎么设计？

![](https://raw.githubusercontent.com/danmuking/image/main/86a54f8061f4081a8f9a8aa2396aa5a8.png)

具体设计可以查看[消息列表的新旧功能](https://www.yuque.com/snab/mallcaht/iklrkbwgotv1vygd)
**总结**
游标翻页的优点：
1.解决深翻页问题
2.解决频繁变动的列表翻页问题。
缺点：
1.无法跳页，只能不断往下翻
游标翻页更适合c端场景，用户只能不断下滑翻页。
普通翻页更适合B端场景。用户能看见总页数，能随意跳页
**游标翻页技术细节**
我们的项目大量使用到了游标翻页，比如会话列表，消息列表，成员列表。其中数据库涉及了redis和mysql。并且封装了分页工具类，接下来就一起看看具体的实现细节。
**redis游标翻页**
redis的zset天然适合游标翻页。

![](https://raw.githubusercontent.com/danmuking/image/main/2771ff37b0ba5d382867413492c058d3.png)

获取指定游标的成员
min-max代表我们要筛选的score范围。根据正序还是倒序，我们只需要用到其中一个字段
offset代表要跳过几个，我们只需要跳过游标那一条记录，固定传1
count代表需要取几行记录。根据前端传的size
工具类需要帮我们做啥呢？
1.zset翻页返回的是set，需要帮我们排序好记录
2.需要帮忙计算好本次游标翻页到哪个位置，直接就能返回给前端。
看看一个成员列表的游标翻页，就是这么简单。

![](https://raw.githubusercontent.com/danmuking/image/main/bd819112864093013fc3a33d30efd447.png)

其中的入参：
pageBaseReq：就是前端给的对象，里面的字段是cursor和size
key：zset的key
convert：zset的socore是什么数据类型，让工具类帮忙转换好。
出参：

![](https://raw.githubusercontent.com/danmuking/image/main/bfe1eb953608598a0a527c0266f3b781.png)

直接帮我们判断好了是不是最后一页，下一次查询的游标，以及这次查询的数据。
如果数据不需要加工的话，这样直接返回前端就好了，非常方便。但是zset一般存的value都是一些id。还需要去查详情进行一步加工。
**mysql游标翻页**
**原生的游标翻页**

![](https://raw.githubusercontent.com/danmuking/image/main/b58f1dee0d3ba3756a5b97a6db801c02.png)

这个是一个完整的游标翻页的写法，也是我们消息列表的游标翻页的写法。
一个游标翻页查询最重要的，就是设定游标，确定方向。
以及查出结果后，要包装给前端的参数 当前游标位置，是否最后一页。
这样的查询基本是一个固定的套路，当你有其他的业务，比如会话列表也需要用到游标翻页，也是按照这个固定套路来进行查询的。
**不知道你们觉得这块代码够不够简单，反正我觉得太臃肿了，再写一遍就吐了。**
我们可以尝试把固定的游标模板抽出来，把可变的作为入参让业务传进来，形成一个工具类。
通过上面的分析，额外查询条件和游标字段这个是可变的，其他都可以抽出来。
**封装后的游标工具类**
mysql的翻页上面也介绍了sql
不同的业务，差别就是游标字段的不同，翻页可能额外加些条件，比如消息列表会加roomId=1。那我们的工具类就需要抽出这些相同的点，把不同的点作为扩展让业务传。

![](https://raw.githubusercontent.com/danmuking/image/main/2b56e224a8d8b2f73e7101180b464ef3.png)

入参：
mapper：mybatisplus的数据库操作类，让工具类能调用一些基础的查询方法。
pageBaseReq：就是前端给的对象，里面的字段是cursor和size
wrapperComsumer：提供的扩展点，业务方可以在sql中拼接一些查询条件。比如只查状态正常的
cursorColumn：游标字段，用于游标查询，以及后续的游标计算。
返回：

![](https://raw.githubusercontent.com/danmuking/image/main/bfe1eb953608598a0a527c0266f3b781.png)

返回的也是可以直接给前端展示的实体类。
项目中两处用到了mysql游标翻页的工具类，实现起来可简单多了。

![](https://raw.githubusercontent.com/danmuking/image/main/5f40ae8c56813f87da724288d8ddc2fd.png)

工具类具体的使用可看源码位置com.abin.mallchat.common.common.utils.CursorUtils

