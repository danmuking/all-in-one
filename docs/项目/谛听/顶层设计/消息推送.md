## 推拉结合
我们刚刚讨论的消息可靠性，讨论的都是后端主动推送给前端。实际上新消息的获取，方案可以有很多。
是推还是拉，用哪些方案，之前的[一篇文章](https://www.yuque.com/snab/mallchat/skb0r8tesr7yitvf)也有相关讨论，大家可以看看
### 推模式
有新消息，服务端需要主动推送给前端。需要用到websocket。并且后台会维护一个定时任务，定时推送还未接收到ack的消息。保证消息的实时性。
### 拉模式
拉模式又分为短轮询和长轮询。前端主动询问后端是否有新消息。以定时的频率访问。我们项目已经用到了websocket，一般就不用拉模式了。**拉模式可以用在历史消息列表**。新消息，还是要保证消息的**即时性**。
缺点：
延迟较高：拉模式需要消费者主动请求数据，可能导致较高的延迟。
重复请求：如果消费者频繁请求相同数据，可能导致带宽浪费和系统效率降低。
### 推拉结合
理论上保证消息的及时性，推模式足够了，为什么还要拉模式？推模式需要考虑推送失败的情况，又需要服务端启动定时任务，确保ack，方案比较复杂，对服务器消耗也大。
实际上推送的失败概率没有那么高，如果客户端每隔一定的频率进行消息拉取。相当于客户端是那个定时任务。就能达到最终一致性。
采用推拉结合。**推主要是保证及时性**。而**拉主要是保证最终一致性**，也就是消息到达的可靠性。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/2fb839191da513952123d093a0610e15.png)

1. 推送新消息到达，里面没有任何特殊消息，仅仅是为了及时触发客户端的消息拉取动作。这个推是无状态的，也就可以任意调用，实现超级简单。
2. 客户端接收到新消息提醒，或者是定时任务到达指定时间。对服务端发送拉取新消息的请求。只需要带个token就好了
3. 服务端查询用户信箱里未ack的消息，全部返回给客户端。达到返回增量消息的目的。
4. 客户端收到消息后，可批量ack，服务端收到ack。将信箱标记为已读取。

接下来讨论几个问题。
服务端在拉取新消息的时候，指定的是两个字段，`uid`=用户，`ack`=false。为了能快速拉取到新消息。是不是需要一个联合索引，`uid&ack`的联合索引。
新消息的推送，仅是一个**无状态通知**，最终一致性是靠客户端的拉取实现的。也就意味着我们先后到达两条消息
aa，bb。aa触发的新消息通知，由于网络异常丢失了。bb消息入库时，进行新消息通知。这时候a拉取新消息的时候，也能把aa给拉到。这是单纯用消息推送无法做到的点。
由于整体的流程都变成无状态的请求了。这样客户端在请求新消息的时候，可以请求到批量的消息。客户端在ack的时候，也从原来的一条条ack，变成了可以批量ack。在大群聊很多消息的时候，我们可以通过控制新消息推送的速度，很很容易的达到合并拉取的效果。
只要我们在**索引上下了功夫**，查询未ack的速度就很快。客户端定时向后端的新消息拉取请求，**不会占用多少cpu**。另外由于没有新消息，拉取到的为空，**也不占用多少带宽**。
通过推拉结合的组合，通过无状态通知，减少服务端的压力。由客户端的请求触发最终一致性。收口了核心的接口达到复用效果。
但是依然**没有解决热点群聊的写扩散**问题，所有的消息依然需要写入到用户收信箱。
抹茶用的很简单，没用到这个方案。但是不妨碍我们被问到的时候，能够回答出来。
## 多端同步
上文提到的推拉结合是个好方案，但是在多端同步的场景下，就失效了。多端同步的核心，是确保消息可靠的到达多端。消息的可靠是通过ack完成的，问题就出来这里。
用户收信箱只有一个，消息的状态分为`ack`=`true`，`false`。代表用户是否已经收到消息。但是在多端的场景下，如何去表示用户收到消息呢？
![image.png](https://raw.githubusercontent.com/danmuking/image/main/4113db2cafed4dec9cd6ffb9c0272d83.png)
这样每个端的ack，都需要独立去维护自己的ack信箱了。手机收到了两条消息，电脑收到了一条。在电脑进行新消息拉取的时候，拉取到的消息应该是2，3，4。而手机端拉取到的应该是3，4。这样的设计可太烂了。难道我们要为每个端都准备一个信箱吗？如果有新的端加入，信箱还需要做历史数据修复吗？为了兼容这个场景，我们不得不去设计一套新的交互方案。
我们来思考一个问题。可靠性，究竟是怎么保证的？是靠状态的持久化来保证的。比如收信箱里的ack，就明确标识了用户接收了哪些，没接收到哪些，之后才能够推送未ack的。保证最终一致性。而现在的状态存储遇到了问题。多端场景下，需要服务端维护**多端状态**。这是一个难题，那么能不能把多端状态抛给客户端？？
![image.png](https://raw.githubusercontent.com/danmuking/image/main/0576d08f0f2381851e25e68a4eccd8c3.png)
服务端不再维护ack状态，由客户端维护。客户端维护该端读取到的最后一条消息的游标。这个**游标**的选择，需要具备**唯一性**和**有序性**。关联上我们前面介绍的，也就是用消息id来保证了。
每次推送，都需要对多端进行新消息通知。
每次拉取新消息的时候，客户端不仅需要带上token，还需要带上自己当前读到的游标。服务端根据游标，查询到id大于游标的消息，全部返回给客户端。
手机请求新消息时，带上的是自己的游标是2。查到大于2的消息3，4。
电脑请求新消息时，带上的是自己的游标是1。查到大于1的消息2，3，4。

这一切的前提，是**id是全局递增**的。这样服务端只需要维护一个游标。每次拉取新消息，都是拉取多个会话的消息。
如果id是**收信箱递增**的，对于单个用户来说，其实相当于是全局递增了。用的是收信箱的id做游标，而不是用消息id。也能达到全局的效果。微信就是这个方案。
如果id是**会话级别递增**的，那么客户端就需要维护每个会话的游标了，每次拉取消息的时候需要带上`会话id＋游标id`。每次定时任务的拉取，也需要带上**多个**`会话id＋游标id`，为每个会话都尝试拉取最新消息。整体实现复杂了不少。这种方案通常不常见。
![image.png](https://raw.githubusercontent.com/danmuking/image/main/c8b7302e869d4d85ca9a143519ef184e.png)
对于抹茶来说，是全局递增的id，完全可以客户端存储阅读游标的方式实现多端消息同步。虽然我们暂时没有去做，但是大家可以这样去回答。
抹茶的多端同步也比较简单，毕竟是一个web项目不保存消息。登录每个端都一样。拉取最新的一页消息。后续新消息通知就拉取新消息。感兴趣历史消息，也可以通过翻页加载的方式加载老消息。对于客户端缓存消息来说，看老消息直接从库里查，都不需要翻页加载了。
