## 为什么需要协程
当今无数的 Web 服务和互联网服务，本质上大部分都是 IO 密集型服务，什么是 IO 密集型服务？意思是处理的任务大多是和网络连接或读写相关的高耗时任务，高耗时是相对 CPU 计算逻辑处理型任务来说，两者的处理时间差距不是一个数量级的。
**IO 密集型服务的瓶颈不在 CPU 处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写。**
**以前有两种解决方案：**

- 如果用多线程，高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换，非常消耗系统资源，同时多线程访问共享资源存在竞争问题。
- 如果用多进程，不仅存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要额外引入进程间通信机制来解决。

**协程出现给高并发和 IO 密集型服务开发提供了另一种选择。**
当然，世界上没有技术银弹，在这里我想把协程这把钥匙交到你手中，但是它也不是万能钥匙，最好的解决方案是贴合自身业务类型做出最优选择，不一定就选择一种模型，有时候是几种模型的组合，比如多线程搭配协程是常见的组合。
## 什么是协程
**那什么是协程呢？协程 Coroutines 是一种比线程更加轻量级的微线程。**类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程，因此协程又称微线程和纤程。

![](https://raw.githubusercontent.com/danmuking/image/main/af382ae94a3522530263484fd5257081.webp)

**可以粗略的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。**

![](https://raw.githubusercontent.com/danmuking/image/main/a4d16d269a1374a39573e965c4e7db34.webp)

### 调度开销
线程是被内核所调度，线程被调度切换到另一个线程上下文的时候，需要保存一个用户线程的状态到内存，恢复另一个线程状态到寄存器，然后更新调度器的数据结构，这几步操作设计用户态到内核态转换，开销比较多。

![](https://raw.githubusercontent.com/danmuking/image/main/3ba3f56431bb5fc36dae5ac15164a6a6.webp)

协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作用户空间栈，完全没有内核切换的开销。

![](https://raw.githubusercontent.com/danmuking/image/main/1345c7bf45951b4ae2e8ae0c60cbe8bb.webp)
## 参考资料
[https://www.cnblogs.com/Survivalist/p/11527949.html](https://www.cnblogs.com/Survivalist/p/11527949.html)
