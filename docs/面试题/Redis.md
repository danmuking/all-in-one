## Redis的应用场景
1. 缓存
2. 分布式锁
3. 限流
## redis的数据结构有哪些

1. SDS
2. List
3. HashMap
4. 跳表
5. 压缩列表
6. 整数集合
7. quick list
8. listpack
## redis健壮性的实现

1. 过期删除策略
   1. 定时删除
      1. 占用主线程，可能导致卡顿
   2. 惰性删除
      1. 占用内存，可能导致oom
   3. 定期删除
      1. 隔一段时间从数据库中取出部分key，删除其中过期的key
   4. redis采用惰性删除和定期删除结合的方式
2. 缓存淘汰策略
   1. LRU算法
   2. LFU算法
## Redis保证incr命令原子性的原理是什么
Redis 的 INCR 命令用于将存储在 Redis 数据库中的键的值递增1。在 Redis 中，该命令的原子性是通过单线程执行命令并使用事务保证的。
Redis 是单线程的，这意味着 Redis 在任何给定的时间点只会执行一个命令。当客户端发送 INCR 命令时，Redis 服务器将它放入待执行的命令队列中，并按顺序处理这些命令。这就确保了 INCR 命令的原子性，即在执行 INCR 命令期间，不会发生其他命令的干扰。
此外，Redis 还支持事务，通过 MULTI 和 EXEC 命令可以实现多个命令的原子性操作。当将 INCR 命令包含在事务中时，Redis 会在执行 EXEC 命令时将整个事务作为一个原子操作执行。这意味着在事务执行期间，即使有其他客户端同时操作相同的键，也不会导致 INCR 命令的结果受到影响。
## 缓存雪崩、缓存击穿、缓存穿透分别是什么

1. 缓存雪崩
   1. 大量的redis缓存在同一时间过期，导致大量数据库请求
2. 缓存击穿
   1. 某一个热点数据过期，导致大量对同一个数据的数据库请求
3. 缓存穿透
   1. 请求不存在的数据
## 缓存雪崩、缓存击穿、缓存穿透如何解决

1. 缓存雪崩
   1. 设置均匀的过期时间
   2. 加互斥锁，只允许一个请求更新缓存
2. 缓存击穿
   1. 加互斥锁，只允许一个请求更新缓存
3. 缓存穿透
   1. 限制恶意请求
   2. 缓存空值
   3. 使用布隆过滤器判断
## redis 如何限流

1. 计数器
   1. 通过redis的计数功能，限制指定时间内的访问次数
2. 滑动窗口
   1. 通过zset结构，利用时间戳做score，查询指定时间内的访问数
3. 令牌桶
   1. 通过list结构实现队列
## redis持久化方式

1. AOF
   1. 保存的是文本格式的数据
   2. 恢复时效率较低
2. RDB
   1. 保存的是内存快照
   2. 恢复速度较快
## AOF重写日志时，有新数据写入怎么办

1. 一个拷贝，两处日志”。
2. 在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个aof日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。
3. 在bgrewriteaof子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞
## redis主从故障转移过程

1. 选出新的主节点
   1. 优先级
   2. 复制进度
   3. 编号
2. 将该节点设为主节点
3. 设置其他节点的主节点
4. 继续监听原主节点，等待上线后将其设为从节点
## RedLock

1. 什么是红锁：红锁是一种可以保证高可用的分布式锁
2. 为什么要有红锁：redisson的常规分布式锁在主节点宕机的时候可能导致多个节点同时获取锁，为了解决这个问题，提出了红锁
3. 红锁的加锁过程：同时向N个节点加锁，如果有N/2+1个节点加锁成功就说明加锁成功
4. 红锁存在的问题：见[链接](https://www.yuque.com/danmu-ix6zd/vaqzuz/gysqgltw8xgh7mgn#zmg9e)
## Redis为什么这么快

1. 基于内存
2. IO多路复用
3. 高效的数据结构
4. 单线程模型
## Redis 哨兵

1. 为什么需要哨兵：实现主从节点的故障转移
2. 哨兵的作用
   1. 监控
   2. 选主
   3. 通知
3. 如何判定节点下线
   1. 哨兵每隔1秒像所有节点发送心跳，节点收到心跳命令后响应哨兵
   2. 如果主节点或者从节点没有在规定时间内响应哨兵的PING命令，就会将他们标记为主观下线
   3. 当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令。当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。
4. 哪个哨兵进行主从故障转移
   1. 哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者
5. 候选者如何选举称为Leader
   1. 候选者会向其他哨兵发送命令
   2. 每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。
6. 主从故障转移的过程
   1. 在已下线主节点属下的所有从节点里面挑选一个从节点，将其转换为主节点
      1. 先选优先级最高的从节点
      2. 然后选复制进行最靠前的节点
      3. 最后选择ID小的节点
   2. 让已下线的主节点属下所有从节点复制目标，修改为复制的新节点
   3. 将主节点的IP地址和信息通过发布/订阅机制通知给客户端
   4. 继续监视主节点，从这个旧主节点重新上线时，将它设置为新主节点的从节点
7. 哨兵集群是如何组成的
   1. 哨兵节点之间通过发布订阅者机制来相互发现
   2. 主节点上有一个名为__sentinel__:hello的频道，不同哨兵之间相互订阅
## Redis集群

1. Cluster模式
   1. 目的
      1. 高可用
      2. 负载均衡
   2. 实现方式：
      1. Redis Cluster将数据分为16384个槽位，每个节点负责管理一部分槽位
      2. 客户端请求时，将根据键的哈希值将请求分发到相应节点
      3. Redis Cluster使用CRC16算法计算键的哈希值，然后对16384取模，得到槽位编号
## Redis的qps
10w+
