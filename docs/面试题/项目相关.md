## 用户登录选型
1. cookie
   1. 存在csrf攻击的风险
   2. cookie存储空间小
   3. cookie与浏览器相关
   4. cookie可能被禁用
2. session
   1. 需要服务器保存对应状态
3. token
   1. 发布后就难以撤回，如果有效时间长，无法及时管理用户，时间短，用户体验差
4. 双token
## JWT
### 什么是JWT
JWT是一种基于token的跨域认证机制
### JWT由哪些部分组成

1. head
2. payload
3. signature
### 如何防止JWT被篡改
 服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。
## 限流注解
### 限流算法

   1. 简单计数算法
   2. 滑动窗算法
   3. 令牌桶算法
### 设计模式

   4. 工厂方法模式
   5. 策略模式
### 流程

   6. 获取方法上的`FrequencyControl`注解
   7. 遍历注解，根据`prefix`和`key`生成redis`key`
   8. 根据频控注解中指定的算法，判断是否放行
## 分布式锁注解
### 分布式锁为什么需要再事务外
如果分布式锁在事务内发生，有可能会出现这样的情况
线程1：

1. 事务开启
2. 线程1获取分布式锁
3. 线程1执行事务
4. 线程1释放分布式锁
5. 线程1提交事务

线程2：

1. 事务开启
2. 未获取到锁，等待
3. 线程2获取线程1释放的锁
4. 线程2执行事务（这一步可能早于线程1提交事务，所以线程1写入的值不可见）

在这种情况下有可能出现重复写的问题。
## 统一线程池管理
### 线程池优雅停机

1. 原理：JVM调用shutdown函数，将线程池状态从Running转换为Shutdown状态
2. 线程池工作状态介绍

线程池工作状态是单调推进的，即从运行时->停止中->完全停止。共有以下五种情况

   1. RUNNING

RUNNING状态，代表着线程池处于正常运行(运行时)。RUNNING状态的线程池能正常的接收并处理提交的任务
ThreadPoolExecutor初始化时对ctl赋予的默认属性便是RUNNING（private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));）
RUNNING状态下线程池正常工作的原理已经在第一篇博客中详细的介绍过了，这里不再赘述。

   2. SHUTDOWN	

SHUTDOWN状态，代表线程池处于停止对外服务的状态(停止中)。不再接收新提交的任务，但依然会将workQueue工作队列中积压的任务逐步处理完。
用户可以通过调用shutdown方法令线程池由RUNNING状态进入SHUTDOWN状态，shutdown方法会在下文详细展开分析。

   3. STOP

STOP状态，代表线程池处于停止状态。不再接受新提交的任务(停止中)，同时也不再处理workQueue工作队列中积压的任务，当前还在处理任务的工作线程将收到interrupt中断通知
用户可以通过调用shutdownNow方法令线程池由RUNNING或者SHUTDOWN状态进入STOP状态，shutdownNow方法会在下文详细展开分析。

   4. TIDYING

TIDYING状态，代表着线程池即将完全终止，正在做最后的收尾工作(停止中)。
在线程池中所有的工作线程都已经完全退出，且工作队列中的任务已经被清空时会由SHUTDOWN或STOP状态进入TIDYING状态。

   5. TERMINATED

TERMINATED状态，代表着线程池完全的关闭(完全停止)。
![](https://raw.githubusercontent.com/danmuking/image/main/66128cf2b38330260825d8f77a7bf3eb.png)
### 线程异常捕获

1. 问题描述
   1. 在默认情况下，线程池中的线程出现异常，不会记录日志，只会在控制台打印，这是因为一场会被线程池的`内置异常捕获器`拦截
   2. `ThreadFactory`中出现异常可以通过添加`自定义异常捕获器`解决
```java
private static ExecutorService executor = new ThreadPoolExecutor(1, 1,
    0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<Runnable>(500), 
    new NamedThreadFactory("refresh-ipDetail",null, false,
                           new MyUncaughtExceptionHandler()));
```

   3. 但是采用`Spring`的`ThreadPoolTaskExecutor`就会出现问题，这是由于`ThreadPoolTaskExecutor`自己重写了一个`CustomizableThreadFactory`，虽然在`ExecutorConfigurationSupport`中提供了设置`ThreadFactory`的方法，但是就无法拥有`CustomizableThreadFactory`中的功能。![image.png](https://raw.githubusercontent.com/danmuking/image/main/242307958b4579648fb88b4602aec98f.png)
   4. 因此我们需要使用装饰器模式，自己实现一个`ThreadFactor`继承`CustomizableThreadFactory`，并设置自己的`异常捕获器`。
## 批量缓存框架

1. 目的：避免需要在批量get的时候需要多次访问redis
2. 流程：
   1. 从redis获取所有缓存，并找到redis中不存在的对象
3. 从数据库批量加载，然后批量放到redis中
## 二级缓存框架

1. 目的：避免对redis的频繁访问
2. 流程：
   1. 获取数据
      1. 从本地缓存加载数据，如果不存在则请求redis
      2. 将数据加载到本地缓存
   2. 增加/修改/删除数据
      1. 当数据发生变化时，需要利用消息队列，发布数据变化通知，清空对应对象的本地缓存
