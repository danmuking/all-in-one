## CPU缓存一致性
### Cache和内存的一致性

1. 写直通
2. 写回
### 多核间的缓存一致性
问题：由于cpu会采用缓存提高效率，因此在内存中的同一个变量可能同时在多个核心中存在副本，且这些副本间相互不可见。
解决方法：

1. 传播机制：当某一个线程改动了副本，其他也使用这个变量的线程需要立刻得知
2. 锁机制：当多个线程同时改变副本，需要按照顺序进行传播

协议：

1. MESI协议
   1. 修改
   2. 独占
   3. 共享
   4. 失效
## 进程相关
### 进程

1. 进程是什么：进程是一个运行中的程序
2. 进程的状态
   1. 创建
   2. 就绪
   3. 阻塞
   4. 运行
   5. 结束
3. 进程的控制结构
   1. PCB（Process Control Block）
      1. pid
      2. 进程状态相关信息
      3. 进行使用的资源列表
      4. cpu相关信息
   2. 就绪队列：一个等待运行的进程的PCB组成的链表
   3. 阻塞队列：一个阻塞状态的进程的PCB组成的链表
4. 进程控制
   1. 创建进程：
      1. 分配一个空白的PCB，写入一些必须的控制信息
      2. 为线程分配内存等所需资源
      3. 将PCB加入就绪队列
   2. 阻塞进程
      1. 找到要阻塞进程的PCB
      2. 如果该线程处于运行态，保存进程上下文，将其状态转换为阻塞态，停止运行
      3. 将PCB插入阻塞队列
   3. 唤醒进程
      1. 在阻塞队列中找到PCB
      2. 将其从阻塞队列中移出，设置状态为就绪状态
      3. 将PCB插入就绪队列中
5. 进程的上下文切换
   1. 进程上下文切换需要保存什么：虚拟内存，栈，全局变量、内核堆栈、寄存器等
   2. 什么时候发生进程上下文切换
      1. 当进程时间片耗尽
      2. 当进行所需资源不足
      3. 当进程结束
      4. 当进程将自己挂起
### 线程

1. 为什么要使用线程：为了降低进程切换的开销
2. 什么是线程：线程是进程中的一条执行流程
3. 线程的控制结构：TCB
4. 进程和线程的区别：
   1. 进程是资源分配的基本单位
   2. 线程的执行的基本单位
5. 线程的实现
   1. 用户级线程
   2. 内核级线程
   3. 轻量级线程
### 协程

1. 为什么需要协程：线程在进行线程切换的时候由操作系统调度，需要比较大的系统开销
2. 什么是协程：协程可以看做是一个更轻量的线程，同时协程的调度完全由用户完成。
### 调度算法

1. 先来先服务
2. 最短作业优先
3. 时间片调度算法
4. 高响应比优先
5. 最高优先级调度算法
6. 多级反馈队列调度算法
### 线程基本状态和转换

1. 创建
2. 运行
3. 阻塞
   - 由synchronized关键字导致的状态
   - 阻塞是被动的，由于对应临界区被锁住导致的状态
4. 无限期等待
   - wait()/notify()引起的状态
   - 等待是主动的，由线程主动调用，等待被唤醒
5. 限期等待
   - sleep()
   - 在过程中不会占用cpu时间，且不会释放锁
6. 死亡
### 死锁

- 死锁的条件
   1. 请求与保持条件
      - 一个进程因请求资源而阻塞时，对已获得的资源保持不放。
   2. 互斥条件
      - 互斥条件：一个资源每次只能被一个进程使用。
   3. 不剥夺条件
      - 进程已获得的资源，在末使用完之前，不能强行剥夺。
   4. 循环等待条件
      - 若干进程之间形成一种头尾相接的循环等待资源关系。
- 如何解决死锁
   1. 死锁预防
      1. 破坏请求和保持条件
         - 一次性分配所有资源
      2. 破坏互斥条件
      3. 破坏不剥夺条件
         1. 当进程请求资源失败时主动释放已经占有的资源
      4. 破坏循环等待条件
         1. 顺序分配
   2. 死锁避免
      1. 银行家算法
   3. 死锁检测和破坏
### 进程间的通信方式

1. 管道
   1. 匿名管道
      1. 特殊的文件，只存在与内存
      2. 通过创建子进程实现通信
   2. 命名管道
   3. 优点：简单
   4. 缺点：通信效率低，不适合频繁的通信
2. 消息队列
   1. 缺点：
      1. 通信不及时
      2. 附件有大小限制
3. 共享内存
4. 信号量
5. 信号
6. Socket
## 内存相关
### 内存回收

1. 对象：
   1. 文件页，内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。
   2. 匿名页，这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。
2. 回收方式：
   1. 异步回收，用户不感知
   2. 同步回收，将会造成卡顿
3. 回收时机
   1. pages_high前，不回收
   2. 小于pages_low，但是大于pages_min，异步回收
   3. 小于pages_min，同步回收

## 文件系统相关
### select、poll和epoll
三者都是操作系统提供的IO多路复用函数

1. select采用一个bitmap来存放对应的文件描述符，
   1. 当发生事件时，需要遍历所有文件描述符来找到对应的文件
   2. 需要进行两次拷贝，第一次将用户态的文件描述符集合拷贝内核态，第二次将内核修改后的文件描述符拷贝到用户态
2. poll与select差不多，只不过poll采用了链表的方式来存放文件描述符，因此比select更多连接
3. epoll维护了一个内核态的文件描述符池，采用红黑树进行管理
   1. 单独维护了一个就绪队列，当发生事件时，通过回调函数，将对应的文件描述符加入就绪队列
   2. 由于内核单独维护了一个文件描述符池，只需要拷贝一个单独的文件描述符

epoll同时支持水平触发和边缘触发

1. 水平触发，当有事件时就会一直发出信号
2. 边缘触发，只有在时间状态转换时才发出一次信号
### 零拷贝

1. 为什么需要零拷贝：传统的DMA拷贝需要性能较差，以网络io为例
   1. dma从io设备拷贝文件-》内核缓冲区
   2. 内核缓冲区-》用户态缓冲区
   3. 用户态缓冲区-》socket缓冲区
   4. socket缓冲区-》网卡
2. 零拷贝的实现
   1. mmap
      1. 原理：将内核缓冲区直接映射到用户态，这样就可以减少一次拷贝
      2. 过程
         1. dma从io设备拷贝文件-》内核缓冲区
         2. 内核缓冲区-》socket缓冲区
         3. socket缓冲区-》网卡
   2. sendfile
      1. 原理，直接将内核缓冲区拷贝到socket缓冲区
      2. 过程：
         1. dma从io设备拷贝文件-》内核缓冲区
         2. 内核缓冲区-》socket缓冲区
         3. socket缓冲区-》网卡
      3. 极限升级：直接拷贝到网卡
         1. dma从io设备拷贝文件-》内核缓冲区
         2. 内核缓冲区-》网卡
### 大文件传输

1. 问题：在操作系统中有一层pagecache，会缓存常用的文件项，如果大文件io的时候会导致pagecache大量失效，所以大文件就应该跳过pagecache。
2. 方式：**针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」**
   1. 异步io避免线程阻塞
   2. 直接io避免pagecache大范围失效
## **惊群效应是什么**
惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个事件的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应。

