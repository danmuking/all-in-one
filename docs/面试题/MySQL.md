## MySQL的底层为什么要用B+树
1. 与红黑树比较
   1. 二叉树，需要层数较高
   2. 平衡操作会带来较大的性能损失
2. 与B树比较
   1. 单点查询
      1. b树数据分布在每一层，导致每一层存储的记录数变小，树更深
      2. b+树数据只存在于叶子节点，，树更矮胖
   2. 范围查询
      1. b树需要采用中序遍历进行查询，实现复杂
      2. 数据之间采用链表连接，实现简单
   3. 插入删除
      1. b+树有更大的冗余空间，较不容易导致树结构变化
## MySQL常见引擎

1. InnoDB
   1. 特点
      1. 支持索引
      2. 支持行锁
      3. 支持事务
      4. 支持外键
   2. 优点
      1. 提供了较好的事务处理，崩溃恢复和并发控制
   3. 缺点
      1. 读写效率差，占用空间大
2. MyISAM
   1. 特点
      1. 支持行锁
   2. 优点
      1. 占用空间小，处理速度快
   3. 缺点
      1. 不支持事务的完整性和并发性
3. MEMORY
   1. 特点
      1. 内存引擎
   2. 优点
      1. 速度快
   3. 缺点
      1. 断电数据易失
## MySQL中的锁有哪些

1. 全局锁
2. 表级锁
   1. 读锁
   2. 写锁
   3. 元数据锁
   4. AUTO INCREASE锁
   5. 意向锁
3. 行锁
   1. 记录锁
   2. 间隔锁
   3. 临键锁
   4. 插入意向锁
## MySQL中的乐观锁与悲观锁

1. **悲观锁** 具有强烈的独占和排他特性，在整个处理过程中将数据处于锁定状态，一般是通过系统的互斥量来实现。当其他线程想要获取锁时会被阻塞，直到持有锁的线程释放锁。MySQL本身就支持锁机制
2. **乐观锁** 对数据的修改和访问持乐观态度，假设不会发生冲突，只有当数据提交更新时才会对数据冲突与否进行检测，如果没有冲突则顺利提交更新，否则快速失败，返回一个错误给用户，让用户选择接下来该如何去做，一般来说失败后会继续重试，直到提交更新成功为止。MySQL本身不提供乐观锁的功能，需要开发者自己实现。普遍的做法是在表中加一个version列，用来标记数据行的版本，当我们需要更新数据时，必须比对version版本，version一致说明这个期间数据没有被其他事务修改过，否则说明数据已经被其他事务修改，需要自旋重试了。
## 索引下推
索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。
## MySQL索引

1. 数据结构
   1. B+树
2. 索引类型
   1. 聚簇索引
      1. 叶子节点保存实际数据
   2. 二级索引
      1. 叶子节点保存索引值和对应的主键id获取索引外的数据需要进行回表
## MySQL的范围查找怎么做

1. 首先利用b+树的性质找到范围中的最小值
2. 然后利用叶子节点的链表，依次遍历
## 联合索引底层存储结构
联合索引和聚簇索引一样，底层都是b+树，只不过聚簇索引的叶子结点中包含有所有数据，而联合索引的叶子节点中只包括索引的列再加上一个主键，便于做回表查询。
## 索引失效的情况

1. 使用左或左右模糊搜索
2. 联合索引非最左匹配
3. OR下存在非索引条件
4. 对索引使用函数
5. 对索引进行计算
6. 隐式类型转换
## 什么时候会发生回表的操作
当使用二级索引时，如果二级索引中不包括所要查询的所有列的时候，需要进行回表，在聚簇索引中查询出完整记录。
## MySQL的四种隔离级别

1. 问题：
   1. 脏读：可能读取到未提交的数据
   2. 不可重复读：同一个事务内多次读取的数据可能不一致
   3. 幻读：一个事务内同样的查询可能查询到不一样数量的结果
2. 隔离级别
   1. 读未提交：上述问题都有
   2. 读提交：不可重复读、幻读
   3. 可重复读（默认级别）：幻读
   4. 串行化：没有问题
3. 可重复读是如何避免幻读的：
   1. 对于快照读来说，利用了mvcc来避免幻读
   2. 对于当前读来说，利用了锁来避免幻读
4. 可重复读中什么情况下会出现幻读
   1. 快照读：[见](https://www.yuque.com/danmu-ix6zd/vaqzuz/nbcct49xd5d2wed9#zALNi)
   2. 当前读：[见](https://www.yuque.com/danmu-ix6zd/vaqzuz/nbcct49xd5d2wed9#zALNi)
## MySQL加锁

1. 加读锁：`SELECT ... LOCK IN SHARE MODE`
2. 加写锁：update、insert、delete都是写锁，SELECT ... FOR UPDATE也是写锁
## MySQL中update查询语句是表锁还是行锁
如果走索引将会加行锁，如果进行全表扫描将会加表锁。
## MySQL中事务会不会自动提交
默认状态下，MySQL是开启自动提交的，每一条语句会被当做一个独立的事务提交。
## MySQL日志
### undo log
作用：实现原子性，在事务没提交前会先记录更新前的数据到undolog，当事务失败时会利用undolog回滚。
刷盘策略：与数据页相同，都需要通过redolog保证持久化。
### redo log
作用：实现持久性，采用write-ahead logging技术，先写日志，在合适的时候在写硬盘
刷盘策略：

1. MySQL正常关闭时
2. 每一秒中自动刷盘
3. 控制参数
   1. 0：不会主动出发刷盘
   2. 1：每次事务提交时，都会刷盘
   3. 2：每次事务提交时，都会写文件，但是刷盘时间由操作系统决定

常见问题：

1. redo log和undo log的区别
2. redo log也是写磁盘，为什么要多此一举
3. redo log是直接写磁盘的吗
4. redo log文件满了怎么办
### bin log
作用：是数据库的全量备份，用于主从同步、备份恢复
刷盘策略：

1. sync_binlog = 0：每次事务提交时只刷新到操作系统，由操作系统决定刷盘时间
2. sync_binlog = 1：每次事务提交时都刷新到硬盘
3. sync_binlog = N：积累N个事务后刷新到硬盘

常见问题：

1. bin log和redo log的区别
2. 两阶段提交
## 慢查询
### explain

1. id
   1. 这是执行计划的ID值，一条SQL语句可能会出现多步执行计划，所以会出现多个ID值
   2. 执行规则
      1. id相同的执行计划从上到下执行
      2. id不同的执行计划从大往小执行
2. select_type
   1. 当前执行的select语句其具体的查询类型
3. table
   1. 表示当前这个执行计划是基于哪张表执行的
4. type
   1. 该字段表示当前语句执行的类型
   2. 取值类型
      1. all 全表扫描
      2. index 全索引扫描
      3. range 基于索引进行范围扫描
      4. ref 基于非主键或唯一索引字段查找数据时，会出现的情况。
      5. const 通过索引一趟查找后就能获取到数据，基于唯一、主键索引字段查询数据时的情况。
5. rows
   1. 这一列代表执行时，预计会扫描的行数，这个数字并不准确但是有很大的参考脚趾，越小越好
6. filtered
   1. 它是一个百分比值，意味着rows满足过滤条件记录的百分比，取值范围是0.00~100.00。
## MySQL的qps
2000
## MVCC

1. 作用：保证普通读的隔离性
2. 实现原理：通过undo log实现
3. 过程：
   1. 在第一次读取数据是生成一个m_ids，记录当前系统中活跃的事务id
   2. 读取数据时
      1. 如果当前事务id小于min_trx_id，说明该记录在事务开始前提交，对于当前事务可见
      2. 如果当前事务id大于max_trx_id，说明该记录在事务后提交，不可见
      3. 如果当前事务id在min_trx_id和max_trx_id之间，检查是否在m_ids中，如果是则不可见
      4. 如果事务id等于creator_trx_id，说明记录由当前事务创建，可见
4. 在读提交隔离级别中，m_ids在每一次读数据时生成
5. 在可重复读隔离级别中，m_ids在事务开始时生成

