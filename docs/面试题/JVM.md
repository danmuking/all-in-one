## 类加载流程
1. 加载
   1. 将class字节码从不同来源（文件，网络...）加载到内存
   2. 双亲委派机制
2. 验证
   1. 验证加载的字节流是否符合虚拟机规范
3. 准备
   1. 给类变量赋初值，只有静态常量赋初始化值
4. 解析
   1. 将常量池内的符号引用转换为直接引用
5. 初始化
   1. 给类变量赋初始化值。
## 解释一下JVM的内存模型
jvm由以下几个部分组成

1. 本地方法栈
2. 虚拟机栈
3. 程序计数器
4. 方法区
5. 堆

其中程序计数器，虚拟机栈、本地方法栈为线程私有；方法区和堆为线程共享。

1. 本地方法栈
   1. 调用c语言编写的本地方法
2. 虚拟机栈
   1. 虚拟机栈的存储单位是栈帧，每一个正在执行的方法对应一个栈帧，最顶部的栈帧是当前栈帧，最顶部栈帧对应的类是当前类。
   2. 栈帧
      1. 局部变量表
         1. 主要用存放局部变量和对变量的引用
         2. 局部变量表由槽组成，每个槽可以存放16字节的数据
      2. 动态链接地址
         1. 用于存放运行常量池中该栈帧所属方法的引用，用于实现动态链接
      3. 返回值地址
         1. 用于存放调用该栈帧对应方法的地址
      4. 操作数栈
         1. 用于存放计算的中间结果。
         2. 采用栈顶缓存使用寄存机进行加速
      5. 其他信息
3. 线程计数器
   1. 用于记录线程当前执行位置
4. 方法区
   1. 用来存放类的原数据信息，在jdk8中可以看做元空间
5. 堆
   1. 用于存放创建的对象
   2. 可以分为年轻代和老年代
      1. 年轻代
         1. 伊甸园区
         2. s0
         3. s1
      2. 老年代
## 对象何时进入老年代

1. 长期存活的对象进入老年代
2. 大对象直接进入老年代，阈值由参数控制
3. 动态对象年龄判定
## 如何判断对象可回收

1. 引用计数法
   1. 原理
   2. 存在的问题：当存在循环引用的时候，对象将永远无法被回收
2. 可达性分析
   1. 从肯定不会被回收的对象，也就是GC Root开始，向下搜索，找到其他被GC Root直接和间接引用的对象。最后，如果一个对象没有被GC Roots直接或间接地引用，那么这个对象就可以被回收了。
   2. 主要GC Root节点：
      1. 虚拟机栈中的对象
      2. 本地方法栈中的对象
      3. 类静态属性引用的对象
      4. 常量引用的对象
      5. 被锁持有的对象

[GC如何判断对象可以被回收_使用finalize()方法判断对象已死后进行显式gc可以有效地回收对象-CSDN博客](https://blog.csdn.net/yanghenan19870513/article/details/114242731)
## 常见的垃圾回收算法有哪些

1. 标记-整理
2. 标记-清除
3. 标记-复制
## 什么是FullGC
回收整个堆和方法区垃圾的gc
## 垃圾回收机制

1. 目的：回收已经不需要的对象
2. 目标对象：堆和方法区
3. 如何判断对象需要被回收
   1. 引用计数算法
      1. 缺点：无法解决循环引用
   2. 可达性分析算法
4. 回收算法
   1. 标记-压缩
      1. 优点：不存在内存碎片
      2. 缺点：速度慢
   2. 标记-清除
      1. 优点：速度快
      2. 缺点：存在内存碎片
   3. 复制
      1. 优点：不存在内存碎片
      2. 缺点：只能利用一半的空间
   4. 分代收集
5. GC类型
   1. minor GC
   2. major GC
   3. full GC
## 为什么要分代

1. 弱分代假说：绝大多数对象都会很快消亡
2. 强分代假说：熬过越多次垃圾收集的对象越难消亡
## 安全点和安全区域

1. 安全点是某些特殊的可以进行GC的位置，首先更新OopMap，然后进行GC
2. 当要进行GC时，将会设置一个特定的标志，各线程自行轮训标志，如果需要GC，现成将会在安全点将自己挂起。当所有线程都进入安全点，就可以开始进行GC
3. 但是如果有一些线程不拥有cpu资源，例如处于阻塞或者sleep状态，那么就无法将自己挂起，因此，JVM提出了安全区域，安全区域指的是某一个引用关系不发生变化的代码片段。
4. 线程在进入安全区域时会先标记自己已经进入安全区域，在更新OopMap时就无需更新这些线程。
5. 在离开安全区域是，需要先检查GC Root是否已经枚举完成，如果没有完成就需要等待完成，如果完成就标记离开安全区域，继续执行。
## 常见的垃圾回收器有哪些

1. 年轻代
   1. Serial
      1. 特点
         1. STW
         2. 单线程
         3. 复制算法
      2. 优点
         1. 简单
      3. 缺点
         1. STW
   2. ParNew
      1. 特点
         1. STW
         2. 多线程
         3. 复制算法
      2. 优点
         1. 多线程
      3. 缺点
         1. STW
   3. Parallel Scavenge
      1. 吞吐量优先
2. 老年代
   1. Serial Old
      1. Serial的老年代版本
      2. 标记整理算法
   2. Parallel Old
      1. Parallel的老年代版本
      2. 标记整理算法
   3. CMS
      1. 特点
         1. 标记清除
         2. 无法处理浮动垃圾
         3. 存在空间碎片
      2. 回收过程
         1. 初始标记
         2. 并发标记
         3. 重新标记
         4. 并发清除
3. G1
   1. 分区模型
   2. 回收过程
      1. 年轻代GC
      2. 年轻代GC+并发标记
      3. 混合回收
      4. fullGC
## GC的时机

1. 调用System.gc()函数请求gc
2. 老年代空间不足
3. 采用复制算法时，空间担保失败
## G1垃圾收集器

1. 特点
   1. 基于Region的内存布局
   2. 软实时
2. 并发标记算法
   1. 原始快照算法
3. 回收过程
      1. 年轻代GC
      2. 年轻代GC+并发标记
      3. 混合回收
      4. fullGC
4. 优点
   1. 软实时
   2. 内存紧凑
5. 缺点
   1. 由于每个Region都需要记录一个记忆集，通常需要占用更大的内存
