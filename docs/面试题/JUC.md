## JMM
1. 什么是jmm：jmm可以简单的理解为一组规范，抽象了线程和主内存的关系，还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范。
2. 为什么需要jmm：为了屏蔽硬件的底层差异，让开发者能够更简单的开发出并发安全的程序
3. happens-before原则和jmm有什么关系：jmm通过happens-before原则，给开发者呈现了一个简单的开发并发安全程序的规则。在底层jmm规则通过禁止部分会改变程序执行结果的重排序来保证并发安全性
4. jmm如何保证原子性、可见性、有序性
   1. 原子性：在 Java 中，可以借助synchronized、各种 Lock 以及各种原子类实现原子性。
   2. 可见性：在 Java 中，可以借助synchronized、volatile 以及各种 Lock 实现可见性。
   3. 有序性：在 Java 中，volatile 关键字可以禁止指令进行重排序优化。
## 线程安全和线程不安全

1. 线程安全：指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
2. 线程不安全：指某个函数、函数库在多线程环境中被调用时，不一定能够正确地处理多个线程之间的共享变量，使程序功能正确完成。
## 线程同步的方式

1. 通过synchronized和ReentrantLock同步
2. 通过volatile关键字同步
3. 通过ThreadLocal同步
4. 通过wait/notify同步
5. 通过阻塞队列同步
## 创建线程的方式有哪些

1. 实现Runnable接口
2. 实现Callable接口
3. 集成Thread
## Volatile关键字

1. 作用
   1. 禁止重排序
   2. 实现可见性
   3. 实现原子性
2. 原理
   1. 可见性
      1. lock
   2. 有序性
      1. JMM happens before规则
      2. 禁止重排序
## Volatile可见性实现原理
Volatile是通过内存屏障来实现可见性，当出现对volatile修饰的变量进行写操作的时候，会加上一个lock前缀指令。将当前线程的缓存写回内存，并通知其他线程该缓存失效，要求重新从内存中读取。
## Volatile为什么要禁止指令重排，能举一个具体的指令重排出现问题的例子吗
假设当前需要创建一个对象实例，对象实例的创建可以分为三个步骤

1. 分配内存空间
2. 初始化
3. 将对象引用赋值给变量

如果发生指令重排，有可能出现下面一种顺序

1. 分配内存空间
2. 将对象引用赋值给变量
3. 初始化

由于在第二步时，其他对象就可以通过变量访问到这个对象，这时的对象还没有进行初始化，就有可能出现问题。
## 讲讲锁

1. 根据是否公平
   1. 公平锁
   2. 非公平锁
2. 根据是否可重入
   1. 可重入锁
   2. 非可重入锁
3. 根据是否加锁
   1. 乐观锁
   2. 悲观锁
4. 根据是否共享
   1. 共享锁
   2. 互斥锁
5. 根据是否进行线程切换
   1. 自旋锁、自适应自旋锁
   2. 非自旋锁
## synchronized原理
synchronized是基于JVM内置锁实现，通过内部对象Monitor(监视器锁)实现，基于进入与退出Monitor对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的Mutex lock（互斥锁）实现，它是一个重量级锁性能较低。
## synchronized锁升级过程
![](https://raw.githubusercontent.com/danmuking/image/main/c6a59ee0684183a41d957685d94ccee3.png)

1. 无锁
2. 偏向锁
   1. 加锁过程
      1. 第一次执行到synchornized区域的时候，采用cas修改偏向锁字段，并且写入线程id
      2. 之后执行到加锁区域的时候，只需要判断线程id是否和当前线程相同，如果不相同，说明发生竞争，升级到轻量锁。所以偏向锁只会有一次cas加锁操作
   2. 解锁过程，轻量级锁不会主动释放锁，关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。
   3. 目的：当一个同步区域只有一个线程访问的时候，偏向锁拥有极好的性能
3. 轻量级锁
   1. 加锁过程
      1. 在当前线程栈中创建一个用于拷贝markword的区域，通过cas将markword拷贝到该区域，然后修改markword为指向当前区域的指针。
      2. 如果cas操作失败，说明当前存在锁竞争，首先进行自旋，失败一定次数，需要膨胀到重量级锁
   2. 解锁过程
      1. 通过cas将之前复制的markword写回，如果写回失败，说明原markword已经被修改(升级为重量级锁)，释放锁，将自己也升级为重量级锁
   3. 目的：当多个线程访问同一个临界区，但是交替执行的时候，可以不阻塞。
4. 重量级锁
## 线程是怎么确定拿到锁的

1. 偏向锁：第一次加锁时采用cas写markword中的偏向锁字段，如果成功了说明拿到锁。之后只需要判断偏向锁字段是否和自己相等
2. 轻量级锁采用cas将指向自己的指针写入markword，成功则获得锁
3. 重量级锁采用cas将监视器锁对象的指针写入markword，底层是操作系统的mutex锁
## Synchronize和ReentrantLock区别

1. synchronized不需要手动解锁，ReentrantLock需要手动解锁
2. ReentrantLock可以等待中断，synchronized无法中断
3. ReentrantLock可以绑定多个条件，synchronized只能绑定一个条件
4. ReentrantLock可以实现公平锁，synchronized只能是非公平锁
## CAS是什么
CAS是compare and swap的简称，是乐观锁的一种实现方式，通过比较当前值和预期值是否一致来完成加锁。可以避免由于阻塞导致的从用户态切换到内核态的开销。
## AQS是什么

1. AQS是一个用来构建锁和同步器的框架
2. AQS的核心思想
   1. 如果被请求的共享资源空闲，就将当前请求资源的线程设置为有效的工作线程
   2. 如果请求的资源被占用，就将暂时获取不到锁的线程加入一个双向队列等待前一个线程唤醒
## AQS获取锁的过程

1. 调用`tryAcquire`尝试获取锁
2. 若失败，首先将节点加入等待队列
3. 若队列不为空，则采用cas将当前节点添加到队尾
4. 若队列为空或cas失败
   1. 自旋
      1. 为空，采用cas先初始化一个头结点
      2. 采用cas将当前节点写入到队尾
5. 判断节点是否为首个节点，如果是，第二次尝试获取锁
6. 否则检查当前节点前是否存在不是`CANCELLED`状态的节点，采用cas将该节点状态设为`SIGNAL`，将当前节点设为该节点的`next`
7. 线程阻塞。
8. 如果执行失败，释放资源
9. 如果当前节点是尾节点，说明后面没有需要唤醒的线程，直接将当前节点移除
10. 如果当期那节点不是尾节点，且前面有不是`CANCELLED`状态的节点，用cas将该节点状态设为`SIGNAL`，将当前节设为`CANCELLED`状态，前一个节点的`next`修改为当前节点的`next`，有`SIGNAL`节点负责后续节点的唤醒
11. 否则需要由当前节点唤醒节点
12. 首先检查当前节点的下一个节点，如果不是`CANCELLED`状态，唤醒下一个节点
13. 否则从队尾开始找到第一个不是`CANCELLED`状态的节点，唤醒对应的线程。
## AQS释放锁的过程

1. 设置当前节点为头结点
2. 如果能找到当前节点前第一个不是`CANCELLED`状态的节点，用cas将该节点状态设为`SIGNAL`，将当前节设为`CANCELLED`状态，前一个节点的`next`修改为当前节点的`next`
3. 如果失败，首先检查当前节点的下一个节点，如果不是`CANCELLED`状态，唤醒下一个节点
4. 否则从队尾开始找到第一个不是`CANCELLED`状态的节点，唤醒对应的线程。
## AQS的节点是怎么加入到队列的

1. 快速判断一下当前队列是否为空
   1. 若不为空，采用cas将当前节点添加到队尾
2. 如果为空或者添加失败
   1. 自旋
      1. 为空，采用cas先初始化一个头结点
      2. 采用cas将当前节点写入到队尾
## 线程池的作用

1. 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗
2. 提高系统响应熟读，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建就能执行
3. 方便线程并发数的管控，如果创建的线程过多有可能出现OOM
## 常见的线程池类型

1. newFixedThreadPool
2. newSingleThreadExecutor
3. newCachedThreadPool
4. ThreadPoolExecutor
## 线程池的过程和核心参数
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              RejectedExecutionHandler handler)
```

1. corePoolSize，核心线程数量，当线程池线程小于核心线程数量时，不管是否有线程空闲都会创建新线程执行
2. maximumPoolSize，线程池最大线程数量，当线程池已经达到corePoolSize，并且阻塞队列已满，若线程池线程数小于maximumPoolSize，则创建新线程执行
3. keepAliveTime，最大存活时间，当线程池线程数大于corePoolSize时，线程最多存活的时间
4. workQueue，阻塞队列
5. handler，当阻塞队列已满，且线程池线程数超过maximumPoolSize，调用拒绝策略进行处理

执行过程

1. 调用核心线程池，当线程池未达到corePoolSize，创建新线程执行
2. 如果核心线程池满了，就将任务加入阻塞队列
3. 如果阻塞队列满了，当线程池线程未达到maximumPoolSize，创建新线程执行
4. 当达到maximumPoolSize，调用拒绝策略进行处理
## 配置线程池的公式

- CPU密集型: 尽可能少的线程，Ncpu+1
- IO密集型: 尽可能多的线程, Ncpu*2，比如数据库连接池
## 讲讲Threadlocal

1. ThreadLocal的作用
   1. 在多线程下，为每一个线程创建一个独立变量的副本，避免因共享变量导致的变量不一致问题
2. ThreadLocal的数据结构
   1. 1.8前，为每一个ThreadLocal创建一个Map，采用线程作key
   2. 1.8后，每个线程独立维护一个Map，采用ThreadLocal作为key
3. ThreadLocal存在的问题
   1. ThreadLocal存在内存泄漏的问题
   2. 原因：
      1. ThreadLocal中存在一个从Thread到Map到Entry的引用链，声明周期和线程声明周期一样长
      2. 若key是强引用类型时，还存在从Entry到key的引用链
4. 如果采用若引用类型，是否就不会发生内存泄漏
   1. 采用弱引用类型是依然会发生内存泄漏，因为从Thread到Map到Entry的引用链仍然存在
5. 既然如此，为什么要采用弱引用类型
   1. 在进行get和set的时候，可以增加一层判断，若Map对应位置的key为null，就可以将value也设为null，相当于额外添加了一层保护
6. ThreadLocal采用什么方法避免哈希碰撞
   1. 线性探测法
      1. 一方面是因为通常一个线程中ThreaLocal的数量不会太多，不容易发生碰撞
      2. 另一方面是因为采用线性探测法的过程中，可以同时检测是否存在key为null的对象，减少内存泄漏
