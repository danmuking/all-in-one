# 小白也能看懂！彻底打通面试难题：MySQL的事务！

## 随便聊聊

> 作为程序员面试的老大难问题，MySQL如何保证事务之间隔离一直是面试官折磨我们的一把好手，这篇文章将从锁和MVCC两个方面详细分析MySQL实现事务的两种方式，吊打面试官不是梦想！废话少说，让我们直接进入正题。

## 什么是事务

要弄明白事务是如何实现的，当然首先要知道事务是什么，简单来说，事务实际上就是若干个不可分割操作的集合，要么全部执行成功，要么全部失败，不能出现其他中间状态。事务的实现必须遵循以下4个特性：

1. **原子性(Atomicity)**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。
2. **一致性（Consistency）**：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如说一个事务的作用是增加50个商品库存，那么当事务结束后，要么成功，商品库存增加50，要么失败，商品库存保持不变。不能出现事务执行成功商品增加20，或是失败商品库存减少10这类不满足数据一致性的情况。
3. **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。
4. **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

那么这四个特性分别需要通过什么技术实现呢？这里以InnoDB为例：

1. 持久性是通过redo log来保证的
2. 原子性是通过undo log来保证的
3. 隔离性是通过MVCC或者锁机制来保证的
4. 一致性是通过持久性+原子性+隔离性来保证

在这篇文章中，我们将着重于讨论隔离性的实现，也就是MVCC和锁机制，这也是最难并且面试官最青睐的部分。

## 并发是如何影响数据库的？

上面我们已经聊过数据库的事务必须要遵守隔离性，那么如果不遵守隔离性将会发生什么有趣的事情呢？接下来让我们来看看。

### 脏写

影响最恶劣的问题叫做脏写，定义如下：如果一个事务修改了另一个未提交事务修改过的数据，就叫做发生了脏写。下面给出一个简单的示意图

这里应该有张图

事务小王和事务小张各自准备对记录小红的男朋友字段进行修改，事务小王已经成功修改记录并且提交，事务小张被拒绝，执行失败，产生了回滚，将会导致事务小王已经修改成功的结果也不见了，这种现象就叫脏写。那事务小张肯定不干了，我辛苦了半天，好不容易成功了，小张失败了关我啥事，咋让我也失败了呢？

### 脏读

第二个问题叫做脏读：如果一个事务读到了另一个未提交事务修改过的数据，就叫做发生了脏读。示意图如下

这里应该有张图

如果事务A正准备向余额中存入了100元，修改了记录信息，但是还没有提交，接着事务B读取了余额，在这时，事务A忽然发现今天自己身上没带够100块，于是撤销了存款操作。这是事务B就懵圈了，这时候事务B读到的数据实际上是不存在的，如果接下来在事务B中进行了如付款这类的操作，那不就无中生有了吗。

### 不可重复读

### 幻读


虽然我们希望不同客户端在并发访问数据库的时候，可以做到相互之间互相隔离，最好做到对于彼此没有任何影响。但是我们也需要认识到，随着隔离程度的不断提高，数据库的性能也越差。举个最极端的情况，当数据库不允许并发访问，也就是只能顺序访问的时候，自然就会有最好的隔离性，因为不同客户之间根本不会相互影响。

事实上，由于数据库有非常多的应用场景，在某些场景下
## SQL标准中的隔离级别

### READ UNCOMMITTED

### READ COMMITTED

### REPEATABLE READ

### SERIALIZABLE

### MySQL支持的隔离级别

## MVCC

### 版本链

### ReadView

## 锁

### 锁的结构

### 一致性读

### 锁定读

### 锁的类型

### 共享锁和独占锁

### 多粒度锁

### MySQL中的行锁和表锁

### InnoDB存储引擎中的锁