# MySQL的页结构

## 随便聊聊

> 在上一篇文章[《揭秘MySQL数据布局：探索记录结构的奥秘》](MySQL%E7%9A%84%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84.md)我们讲到了 MYSQL 中每一条记录的结构，那么在 MySQL 中，数据也是按照记录为单位存放在硬盘上的吗？如果 MySQL 以记录为单位进行存放，那么当我们每访问一条记录我们就需要进行一次磁盘 io。我们都知道，相对于内存来说，磁盘的速度是非常慢的。而一次查询我们可能需要读取成千上万乃至几十万条记录，也就需要几十万次 io，这将极大的限制MySQL的性能。因此 MySQL 需要一个新的，更加优雅的数据组织结构：页。

## 记录在页中是如何存储的

### 页是什么？

简单点来说，页实际上就是若干条记录所组成的一个更大的集合。使用这个大集合来操作数据有什么好处呢？
在计算机中，有两个非常重要的假设：

1. 空间局部性：一旦某个存储单元被访问，其附近的存储单元也很有可能将被访问。这是因为数据通常是以数组、表为结构进行存储，而我们对数据的操作通常是连贯的，程序操作数据的方式通常也是通过循环来访问连续的数据。
2. 时间局部性：如果某数据被访问过，不久以后该数据可能再次被访问。

根据这两条假设，如果某一条记录被访问到，那么我们就可以将这条记录左右的若干条记录一次性加载到内存里面，反正这些数据有非常大的可能会被访问到，不如直接梭哈，单车换摩托就在此刻。
> 可能有的同学会不理解，如果同样读取10条记录，采用页来读取记录和直接读取记录，好像最终都是要访问相同大小的磁盘存储单元，甚至于页中还需要保存额外的存储信息，读取页所需要访问的存储单元数量应该大于直接访问对应的记录，为什么访问页能够提高 io 性能？
> 这是由于同一页的数据在磁盘上是连续存储的，访问页进行的是顺序 io，而10条记录在磁盘上就不一定连续了，进行的是随机 io。对于磁盘来说，顺序 io 的速度比随机 io 更快。

在 MySQL 中，默认情况下每一个数据页的大小将被设置为 **`16KB`**

### 猫一眼数据页的结构

这里应该有张图

MySQL的数据页被划分为7个部分，分别对应不同的功能，下面我们通过表格简单的罗列一下不同部分的职责。

| 名称      | 描述 |
| :----: | :----: |
| File Header      | 页的一些通用信息       |
| Page Header   | 数据页的专有信息        |
|Infimum + Supermum| 最大记录和最小记录 |
|User Records | 实际存储的行记录 |
| Free Space | 页面中尚未使用的空间 |
|Page Director | 页目录 |
|File Trailer | 文件尾部 |

接下来我们就来具体介绍一下这些结构以及它们的作用。

<!-- TODO: 最大最小记录忘记写进去了 -->
### 记录才是根本目的

前面提到，页这个概念的提出，核心目的就是为了能够让 MySQL 能够拥有更快的记录读取速度，因此页的核心作用就是存放记录。记录在页中的存放自然就是重中之重。
在上面已经介绍过数据页的几大部分，在一个页中所有的用户记录都将会被存放在 User Records 中。当插入一条新记录时，MySQL 首先将会检查 Free Space 是否还有足够的空间可以分配给新记录；如果**空间足够**，就从 Free Space 中分配出一部分空间用来保存新记录；如果发现 Free Space 中已经**没有剩余空间**，或是剩余空间已经不足以存放新记录时，就表明当前页已满，需要申请一个新页。
通过上面的描述，可以发现，新记录的空间是在插入新纪录是才进行分配的。链表正好与这种分配方式相匹配，因此纪录在页中采用链表的数据结构进行存储。
链表结构自然需要拥有指向下一个节点的链表指针，在记录中链表指针存放在什么地方呢？让我们再来回忆一下[《揭秘MySQL数据布局：探索记录结构的奥秘》](MySQL%E7%9A%84%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84.md)中的记录结构![Alt text](img/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F.png)
在额外信息部分中，有一个字段叫做记录头信息，这一个字段中就包含着一条记录中所有的额外结构信息，所以记录的链表指针自然也被包含在这部分中。当然，记录头中还包括其他很多信息，不过现在暂时可以不用关心。那么在数据页中，我们的记录的存储方式就可以用一张图片简单的表示出来：

这里也该有张图

接下来，对于记录的操作就等同于对链表进行操作，不过需要注意的是，在进行删除操作的时候，MySQL 进行了一些特别的优化。当删除某一条记录的时候， MySQL 并不会立刻回收这条记录所占用的空间，而是会在记录头信息中标记一下当前记录已经被删除，并且将这条记录加入到一个被称为垃圾链表的链表中。之后如果有新的记录插入到这个表中，这些记录所占用的空间就有可能被重新利用。
> 为什么不立刻将空间进行回收呢？如果删除的记录正好在链表的尾部，那么将空间回收到 Free Space 中确实很简单，但是如果删除的记录处于链表中间某个位置，那么回收这部分空间就需要重新排列删除节点之后的所有链表节点。这么做是在是不太值当。因此不如使用一个链表把他们记录下来，等待再次利用。

### 加速！加速！加速！

前面说到了记录在页中是采用链表这个结构进行存储的。链表虽然在删除和插入中可以带来一定的方便，但是别忘了，在数据库的使用中，查询是至关重要的功能。而这正是链表的劣势，如果我们想要根据主键的值查询某一条记录，那么就只能沿着链表的一个节点一个节点的查找。如果一个页内存储了很多的记录，采用这种方法就太呆了。如何才能在既保留链表优点的同时还能提高查询的性能呢？MySQL 想出了一个办法，索引。
MySQL 首先将同一页中的记录分为若干个组，接下来开辟一个数组，数组中的每个元素将会保存两个数据，分别是一个指向每一组第一条记录的指针，以及每组第一条记录的主键值。如下图所示：

这里应该有张图。

<!-- 有点绕口了 -->
有了这个索引，在查询记录时，就可以采用二分查找（在一个有序数组中查找元素二分查找是一个最通用的方法啦）在这个数组中查询到第一个大于当前想要查找的主键值的元素的前一个元素，我们想要查找的元素就在当前元素的所属的组中。接下来就只要遍历这个组中的所有链表元素，就可以找到想要查找的值。这样子，原来需要遍历整个链表的记录才能够查询到的值现在最多只需要遍历一个组的记录就能找到，大大的增加了查询的性能。

MySQL将这一个用于索引的数组统一存放在页的 Page Directory 中，将数组中的每一个元素称为槽。

## 页面头部、文件头部和文件尾部

写到这里，其实这篇文章想要说明的主要问题已经解决了，接下来简单说明一下数据页中剩余的三个部分：

### Page Header

在这部分中，将会存储数据页中的一些统计信息。例如本页中存储了多少条记录，第一条记录的地址是多少，页目录中存储了多少个槽等等，这里不做具体说明，如果想要继续深入学习，这里给一个地址《》。

### File Header 和 File Trailer

与 Page Header 的功能相同，File Header 同样负责存储管理信息。他们的不同点在于，Page Header 是数据页专属的，存放的是专属于数据页的管理信息。File Header 则是所有类型页的通用管理信息。在 File Header 的信息里，有两个功能比较重要。在 MySQL 中，记录是以页为单位进行存储的，一个表可能由若干个页组成，因此，为了保存页与页之间的关系，同样采用链表的方式进行连接。

这里页应该有张图。

同时，MySQL 中的数据最终将会被保存到磁盘等介质中进行持久化，但是保不齐在页刚写入一半的时候就发生断电、程序崩溃等无法预料的问题。这样，在进行读取的时候，这一页的数据不就发生丢失了吗。这样的数据实际上不应该被读取。为了应对这种突发情况，MySQL 在 File Header 和 File Trailer 中都设置了一个校验和字段。当读取页面数据时，首先分别从 File Header 和 File Trailer 中读取出校验和，比较两个校验和是否相同。如果 File Header 和 File Trailer 中的校验和相同，说明当前页面已经被完整写入到页面中，如果不相同，就说明当前页面存在不一致问题。

> 小结一下：对于MySQL中的每一条记录有以下几个知识点：
> 
> 1. 在 MySQL 中，使用页作为和磁盘交互的基本单位
> 2. 记录在页中，使用链表的形式进行存储。
> 3. 为了提升性能，MySQL 将同一页中的记录划分为若干组，并且为每个组建立索引来提升搜索效率。
> 4. 为了避免页面未完全同步的问题，分别在 File Header 和 File Trailer 设置一个校验和字段，用于确认页是否同步。