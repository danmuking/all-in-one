# MySQL的页结构

## 随便聊聊

> 在上一篇文章[《揭秘MySQL数据布局：探索记录结构的奥秘》](MySQL%E7%9A%84%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84.md)我们讲到了 MYSQL 中每一条记录的结构，那么在 MySQL 中，数据也是按照记录为单位存放在硬盘上的吗？如果 MySQL 以记录为单位进行存放，那么当我们每访问一条记录我们就需要进行一次磁盘 io。我们都知道，相对于内存来说，磁盘的速度是非常慢的。而一次查询我们可能需要读取成千上万乃至几十万条记录，也就需要几十万次 io，这将极大的限制MySQL的性能。因此 MySQL 需要一个新的，更加优雅的数据组织结构：页。

## 记录在页中是如何存储的

### 页是什么？

简单点来说，页实际上就是若干条记录所组成的一个更大的集合。使用这个大集合来操作数据有什么好处呢？
在计算机中，有两个非常重要的假设：

1. 空间局部性：一旦某个存储单元被访问，其附近的存储单元也很有可能将被访问。这是因为数据通常是以数组、表为结构进行存储，而我们对数据的操作通常是连贯的，程序操作数据的方式通常也是通过循环来访问连续的数据。
2. 时间局部性：如果某数据被访问过，不久以后该数据可能再次被访问。

根据这两条假设，如果某一条记录被访问到，那么我们就可以将这条记录左右的若干条记录一次性加载到内存里面，反正这些数据有非常大的可能会被访问到，不如直接梭哈，单车换摩托就在此刻。
> 可能有的同学会不理解，如果同样读取10条记录，采用页来读取记录和直接读取记录，好像最终都是要访问相同大小的磁盘存储单元，甚至于页中还需要保存额外的存储信息，读取页所需要访问的存储单元数量应该大于直接访问对应的记录，为什么访问页能够提高 io 性能？
> 这是由于同一页的数据在磁盘上是连续存储的，访问页进行的是顺序 io，而10条记录在磁盘上就不一定连续了，进行的是随机 io。对于磁盘来说，顺序 io 的速度比随机 io 更快。

在 MySQL 中，默认情况下每一个数据页的大小将被设置为 **`16KB`**

### 猫一眼数据页的结构

这里应该有张图

MySQL的数据页被划分为7个部分，分别对应不同的功能，下面我们通过表格简单的罗列一下不同部分的职责。

| 名称      | 描述 |
| :----: | :----: |
| File Header      | 页的一些通用信息       |
| Page Header   | 数据页的专有信息        |
|Infimum + Supermum| 最大记录和最小记录 |
|User Records | 实际存储的行记录 |
| Free Space | 页面中尚未使用的空间 |
|Page Director | 页目录 |
|File Trailer | 文件尾部 |

接下来我们就来具体介绍一下这些结构以及它们的作用。

### 记录才是根本目的

前面提到，页这个概念的提出，核心目的就是为了能够让 MySQL 能够拥有更快的记录读取速度，因此页的核心作用就是存放记录。记录在页中的存放自然就是重中之重。
在上面已经介绍过数据页的几大部分，在一个页中所有的用户记录都将会被存放在 User Records 中。当插入一条新记录时，MySQL 首先将会检查 Free Space 是否还有足够的空间可以分配给新记录；如果**空间足够**，就从 Free Space 中分配出一部分空间用来保存新记录；如果发现 Free Space 中已经**没有剩余空间**，或是剩余空间已经不足以存放新记录时，就表明当前页已满，需要申请一个新页。
通过上面的描述，可以发现，新记录的空间是在插入新纪录是才进行分配的。链表正好与这种分配方式相匹配，因此纪录在页中采用链表的数据结构进行存储。
链表结构自然需要拥有指向下一个节点的链表指针，在记录中链表指针存放在什么地方呢？让我们再来回忆一下[《揭秘MySQL数据布局：探索记录结构的奥秘》](MySQL%E7%9A%84%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84.md)中的记录结构![Alt text](img/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F.png)
在额外信息部分中，有一个字段叫做记录头信息，这一个字段中就包含着一条记录中所有的额外结构信息，所以记录的链表指针自然也被包含在这部分中。当然，记录头中还包括其他很多信息，不过现在暂时可以不用关心。那么在数据页中，我们的记录的存储方式就可以用一张图片简单的表示出来：

这里也该有张图

接下来，对于记录的操作就等同于对链表进行操作，不过需要注意的是，在进行删除操作的时候，MySQL 进行了一些特别的优化。当删除某一条记录的时候， MySQL 并不会立刻回收这条记录所占用的空间，而是会在记录头信息中标记一下当前记录已经被删除，并且将这条记录加入到一个被称为垃圾链表的链表中。之后如果有新的记录插入到这个表中，这些记录所占用的空间就有可能被重新利用。
> 为什么不立刻将空间进行回收呢？如果删除的记录正好在链表的尾部，那么将空间回收到 Free Space 中确实很简单，但是如果删除的记录处于链表中间某个位置，那么回收这部分空间就需要重新排列删除节点之后的所有链表节点。这么做是在是不太值当。因此不如使用一个链表把他们记录下来，等待再次利用。

#### 加速！加速！加速！

## 页目录

## 页面头部、文件头部和文件尾部